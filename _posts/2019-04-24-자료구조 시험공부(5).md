---
title: 자료구조 시험공부(5) Trees(2)
tag: data
---

## Trees

## Binary Tree

binary tree는 정렬된 트리.

- 각각의 노드들은 2개의 자식을 가지고 있다. (degree of a binary tree = 2)
- 각 자식 노드는 left child와 right child로 이름 붙여진다.
- 트리가 비어있거나 그렇지 않다면 root, left subtree, right subtree로 구성된다.

## binary Tree Termonology

- Left subtree
- right subtree
- proper binary tree : 트리의 각 노드는 0 또는 2개의 자식을 가진다. (full binary tree)
- Improper binary tree: proper 가 아닌 바이너리 트리
- Skewed tree: 왼쪽 혹은 오른쪽으로 계속 이어지는 트리.

### Decision Tree

- Internal nodes : 자식이 있는 트리는 "Yes" or "no"라는 답을 가질 수 있는 질문들로 구성
- External nodes: decisions

### Arithmetic Expression Tree

- Internal nodes : operators
- External nodes: operands

## Binary Tree Operations

- node left(node v)
- node right(node v)
- boolean hasLeft(node v)
- boolean hasRight(node v)
- integer getDepth(node v)
- integer getHeight(node v)
- node addRoot(object e)
- node insertLeft(node v, object e)
- node insertRight(node v, object e)
- node remove(node v)
  - exception, if v has two children
- attach(node v, T1, T2)
  -     exception, if v is not external

## Array-List Representations of Binary Trees

- if v is the root, p(v) = 1 (0 never used)
- if v is the left child of node u, p(v) = 2 \* p(u)
- if v is the right child of node u, p(v) = 2 \* p(u) + 1

### Printing Arithmetic Expressions

```java
Algorithm printExpr(v)
	if hasLeft(v)
    	print("(")
        printExpr(left(v))
    print(v.element())
    if hasRight(v)
    	printExpr(right(v))
       	print(")")
```

### Evaluating Arithmetic Expressions

```java
Algorithm evalExpr(v)
	if is External(v)
    	return v.element()
    else // visiting internal nodes
    	x <- evalExpr(leftChild(v))
        y <- evalExpr(rightChild(v))

        // combine and return results
        op <- operator stored at v
        return (x op y)
```

### Euler Tour Traversal

## 실습 1 MyBinNode

```java
package tree;


public class MyBinNode extends MyNode {
	// 0 : left, 1 : right

	MyBinNode(){
		super();
	}

	MyBinNode(Object e){
		super(e);
	}

	public MyBinNode left( ) {
		return (MyBinNode)super.children().get(0);
	}

	public MyBinNode right() {
		return (MyBinNode)super.children().get(1);
	}

	public void setLeft(MyBinNode v) {
		super.children().set(0, v);
	}

	public void setRight(MyBinNode v) {
		super.children().set(1, v);
	}

}


```

## 실습 2 : MyBinTree

```java
public class MyBinTree extends MyTree {

	MyBinTree(){
		super();
	}

	MyBinTree(Object e){
		super(e);
	}

	public boolean isEmpty() {
		return super.size() == 0;
	}

	public boolean isRoot(MyBinNode v) {
		return v.parent() == null;
	}

	public boolean isInternal(MyBinNode v) {
		return !this.isExternal(v);
	}

	public boolean isExternal(MyBinNode v) {
		if(!this.hasLeft(v) && !this.hasRight(v))
			return true;
		else
			return false;
	}

	public MyBinNode root() {
		return (MyBinNode)super.root();
	}

	public MyBinNode parent (MyBinNode v) {
		return (MyBinNode)v.parent();
	}

	public MyBinNode left (MyBinNode v) {
		return (MyBinNode)v.children().get(0);
	}

	public MyBinNode right (MyBinNode v) {
		return (MyBinNode)v.children().get(1);
	}

	public boolean hasLeft (MyBinNode v) {
		return v.children().get(0) != null;
	}

	public boolean hasRight (MyBinNode v) {
		return v.children().get(1) != null;
	}

	public MyBinNode addRoot (Object e) {
		return (MyBinNode)super.addRoot(e);
	}

	public MyBinNode inserLeft(MyBinNode v, Object e) {

		MyBinNode mbn = null;

		if(!this.hasLeft(v)) {
			mbn = (MyBinNode)super.setChild(v, 0, e);
		}

		return mbn;
	}

	public MyBinNode inserRight(MyBinNode v, Object e) {

		MyBinNode mbn = null;

		if(!this.hasRight(v)) {
			mbn = (MyBinNode)super.setChild(v, 1, e);
		}

		return mbn;
	}

	public MyBinNode addNode (Object e) {

		MyBinNode return_node = null;

		if(hasLeft((MyBinNode)super.root()) && hasRight((MyBinNode)super.root())) {
			// 2 children exist
			System.out.println("Can't add Node because Two Children exist !");
		}
		else if(hasLeft((MyBinNode)super.root())) {
			// left children exist - addNode to right
			return_node =  this.inserRight((MyBinNode)super.root(), e);
		}
		else if(hasRight((MyBinNode)super.root())){
			// right children exist - addNode to left
			return_node =  this.inserLeft((MyBinNode)super.root(), e);
		}
		else {
			// children is empty
			return_node =  this.inserLeft((MyBinNode)super.root(), e);
		}

		return return_node;
	}

	public Object replace(MyBinNode v, Object e) {
		Object temp = v.element();
		v.setElement(e);
		return temp;
	}

	public MyBinNode remove(MyBinNode v) throws TwoChildrenException {

		MyBinNode parent = (MyBinNode)v.parent();

		int idx = 0;

		if(this.left(parent) == v) {
			// v�� parent�� leftNode
			idx = 0;
		}
		else {
			// v�� parent�� rightNode
			idx = 1;
		}

		if(this.hasLeft(v) && this.hasRight(v)) {
			// two children
			throw new TwoChildrenException("TwochildException!!");
		}
		else if(this.hasLeft(v)) {
			// one children - left
			MyBinNode children = (MyBinNode)v.children().get(0);
			parent.children().set(idx, children);
			children.setParent(parent);
		}
		else if(this.hasRight(v)) {
			// one children - right
			MyBinNode children = (MyBinNode)v.children().get(1);
			parent.children().set(idx, children);
			children.setParent(parent);
		}
		else {
			// no children
			parent.children().set(idx, null);
		}

		return v;
	}

	public void attach (MyBinNode v, MyBinNode t1, MyBinNode t2) throws NotExternalException{

		if(this.isExternal(v)) {
			this.inserLeft(v, t1.element());
			this.inserRight(v, t2.element());
		}
		else {
			throw new NotExternalException("NotExternalException !!");
		}

	}

	public void preOrder(MyBinNode v) {

		System.out.print(v.element()+" ");

		if(this.hasLeft(v))
			preOrder(this.left(v));

		if(this.hasRight(v))
			preOrder(this.right(v));


	}

	public void inOrder(MyBinNode v) {

		if(this.hasLeft(v)) {
			System.out.print("(");
			inOrder(this.left(v));
		}

		System.out.print(v.element()+"");

		if(this.hasRight(v)) {
			inOrder(this.right(v));
			System.out.print(")");
		}

	}

	public int postOrder(MyBinNode v) {

		if(this.isExternal(v))
			return Integer.parseInt((v.element().toString()));
		else {
			int x = postOrder(v.left());
			int y = postOrder(v.right());

			int return_val = 0;

			switch(v.element().toString()) {
			case "+":
				return_val = x + y;
				break;
			case "X":
				return_val = x * y;
				break;
			case "*":
				return_val = x * y;
				break;
			case "-":
				return_val = x - y;
				break;
			}

			return return_val;
		}

	}


	class TwoChildrenException extends Exception {

		TwoChildrenException(String msg){
			super(msg);
		}

	}

	class NotExternalException extends Exception {

		NotExternalException(String msg){
			super(msg);
		}
	}

}



```

## 실습 3

```

public class week6_main {

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub

		MyBinTree mbt = new MyBinTree("+");
		mbt.addNode("X");
		mbt.addNode("X");
		mbt.inserLeft(mbt.root().left(), "2");
		mbt.inserRight(mbt.root().left(), "-");
		mbt.inserLeft(mbt.root().left().right(), "3");
		mbt.inserRight(mbt.root().left().right(), "1");
		mbt.inserLeft(mbt.root().right(), "3");
		mbt.inserRight(mbt.root().right(), "2");

		mbt.inOrder(mbt.root());
		System.out.print(" = ");
		System.out.println(mbt.postOrder(mbt.root()));

	}

}
```

---

하영국 교수님 자바 수업
