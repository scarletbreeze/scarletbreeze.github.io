---

title: 자료구조 시험공부(5) Trees(2)
tag: data

---

## Trees

## Binary Tree 

binary tree는 정렬된 트리. 
*	각각의 노드들은 2개의 자식을 가지고 있다. (degree of a binary tree = 2)
*	각 자식 노드는 left child와 right child로 이름 붙여진다.
*	트리가 비어있거나 그렇지 않다면 root, left subtree, right subtree로 구성된다.

## binary Tree Termonology

*	Left subtree 
*	right subtree
*	proper binary tree : 트리의 각 노드는 0 또는 2개의 자식을 가진다. (full binary tree)
*	Improper binary tree: proper 가 아닌 바이너리 트리
*	Skewed tree: 왼쪽 혹은 오른쪽으로 계속 이어지는 트리.

### Decision Tree

*	Internal nodes : 자식이 있는 트리는 "Yes" or "no"라는 답을 가질 수 있는 질문들로 구성
*	External nodes: decisions

### Arithmetic Expression Tree
*	Internal nodes : operators
*	External nodes: operands

## Binary Tree Operations

-	node left(node v)
-	node right(node v)
-	boolean hasLeft(node v)
-	boolean hasRight(node v)
-	integer getDepth(node v)
-	integer getHeight(node v)
-	node addRoot(object e)
-	node insertLeft(node v, object e)
-	node insertRight(node v, object e)
-	node remove(node v)
	-	exception, if v has two children
-	attach(node v, T1, T2)
	- 	exception, if v is not external

## Array-List Representations of Binary Trees

*	if v is the root, p(v) = 1 (0 never used)
*	if v is the left child of node u, p(v) = 2 * p(u)
*	if v is the right child of node u, p(v) = 2 * p(u) + 1

### Printing Arithmetic Expressions

```
Algorithm printExpr(v)
	if hasLeft(v)
    	print("(")
        printExpr(left(v))
    print(v.element())
    if hasRight(v)
    	printExpr(right(v))
       	print(")")
```

### Evaluating Arithmetic Expressions

```
Algorithm evalExpr(v)
	if is External(v)
    	return v.element()
    else // visiting internal nodes
    	x <- evalExpr(leftChild(v))
        y <- evalExpr(rightChild(v))
        
        // combine and return results
        op <- operator stored at v
        return (x op y)
```

### Euler Tour Traversal

## 실습 1 MyBinNode

```
package tree;

public class MyBinNode extends MyNode{
	
	
	MyBinNode(){
		super();
	}
	
	MyBinNode(Object e){
		super(e);
	}
	
	public MyBinNode left() {
		return (MyBinNode) this.children().get(0);
	}
	public MyBinNode right() {
		return (MyBinNode) this.children().get(1);
	}
	public void setLeft(MyBinNode v) {
		this.children().set(0, v);
	}
	public void setRight(MyBinNode v) {
		this.children().set(1, v);
	}
	
}

```

## 실습 2 : MyBinTree

```
package week6;

import java.util.ArrayList;

public class MyBinTree extends MyTree{

	MyBinTree(){
		super();
	}
	
	MyBinTree(Object e){
		super(e);					
		super.root().children().add(null);
		super.root().children().add(null);
	}
	
	
	public boolean isEmpty() {
		return super.size() == 0;
	}
	
	public boolean isRoot(MyBinNode v) {
		return v.parent() == null;
	}
	
	public boolean isInternal(MyBinNode v) {
		return !this.isExternal(v);		
	}
	
	public boolean isExternal(MyBinNode v) {
		if(!this.hasLeft(v) && !this.hasRight(v))
			return true;
		else
			return false;
	}
	
	public MyBinNode root() {		
		return (MyBinNode)super.root();
	}
	
	public MyBinNode parent (MyBinNode v) {
		return (MyBinNode)v.parent();
	}
	
	public MyBinNode left (MyBinNode v) {
		return (MyBinNode)v.children().get(0);
	}
	
	public MyBinNode right (MyBinNode v) {
		return (MyBinNode)v.children().get(1);
	}
	
	public boolean hasLeft (MyBinNode v) {		
		return v.children().get(0) != null;
	}
	
	public boolean hasRight (MyBinNode v) {		
		return v.children().get(1) != null;
	}
	
	public MyBinNode addRoot (Object e) {		
		MyBinNode temp = (MyBinNode)super.addRoot(e);
		super.root().children().add(null);
		super.root().children().add(null);
		return temp;		
	}
	
	public MyBinNode addNode (Object e) {
				
		MyBinNode return_node = null;
												
		if(hasLeft((MyBinNode)super.root()) && hasRight((MyBinNode)super.root())) {
			// 2 children exist
			System.out.println("MBT-addNode-case 1 : Children Node is FULL!");					
		}
		else if(hasLeft((MyBinNode)super.root())) {			
			// left children exist - addNode to right
			System.out.println("MBT-addNode-case 2 : left Node is exist");					
			super.removeChild(super.root(), 1);
			
			MyBinNode newNode = (MyBinNode)super.addNode(e);	
			newNode.children().add(null);
			newNode.children().add(null);
			
			return_node =  newNode;
		}
		else if(hasRight((MyBinNode)super.root())){
			// right children exist - addNode to left
			System.out.println("MBT-addNode-case 3 : right Node is exist");									
			MyBinNode temp = (MyBinNode)(super.removeChild(super.root(), 1));
			super.removeChild(super.root(), 0);			
			
			MyBinNode newNode = (MyBinNode)super.addNode(e);	
			newNode.children().add(null);
			newNode.children().add(null);
			
			MyBinNode reNode = (MyBinNode)super.addNode(temp);			
			reNode.children().add(null);
			reNode.children().add(null);
			
			return_node =  newNode;
		}
		else {
			// children is empty
			System.out.println("MBT-addNode-case 4 : children is empty");			
			super.removeChild(super.root(), 0);
			super.removeChild(super.root(), 0);
			
			MyBinNode newNode = (MyBinNode)super.addNode(e);	
			newNode.children().add(null);
			newNode.children().add(null);
			
			super.root().children().add(null);			
		}
		
		return return_node;
	}
	
	public MyBinNode inserLeft(MyBinNode v, Object e) {
		
		MyBinNode mbn = null;
		
		if(!this.hasLeft(v)) {			
			mbn = (MyBinNode)super.setChild(v, 0, e);
			mbn.children().add(null);
			mbn.children().add(null);
		}
		
		return mbn;
	}
	
	public MyBinNode inserRight(MyBinNode v, Object e) {		
		
		MyBinNode mbn = null;
		
		if(!this.hasRight(v)) {
			mbn = (MyBinNode)super.setChild(v, 1, e);
			mbn.children().add(null);
			mbn.children().add(null);
		}
		
		return mbn;		
	}
	
	public Object replace(MyBinNode v, Object e) {
		Object temp = v.element();
		v.setElement(e);
		return temp;
	}
	
	public MyBinNode remove(MyBinNode v) throws TwoChildrenException {
		
		MyBinNode parent = (MyBinNode)v.parent();
		
		int idx = 0;
		
		if(this.left(parent) == v) {
			// v�� parent�� leftNode
			idx = 0;
		}
		else {
			// v�� parent�� rightNode
			idx = 1;
		}
		
		if(this.hasLeft(v) && this.hasRight(v)) {
			// two children
			throw new TwoChildrenException("TwochildException!!");
		}
		else if(this.hasLeft(v)) {
			// one children - left			
			MyBinNode children = (MyBinNode)v.children().get(0);
			parent.children().set(idx, children);
			children.setParent(parent);							
		}
		else if(this.hasRight(v)) {
			// one children - right
			MyBinNode children = (MyBinNode)v.children().get(1);			
			parent.children().set(idx, children);
			children.setParent(parent);					
		}
		else {
			// no children			
			parent.children().set(idx, null);				
		}		
			
		return v;
	}
	
	public void attach (MyBinNode v, MyBinNode t1, MyBinNode t2) throws NotExternalException{
		
		if(this.isExternal(v)) {
			this.inserLeft(v, t1.element());
			this.inserRight(v, t2.element());
		}
		else {
			throw new NotExternalException("NotExternalException !!");
		}
		
	}
	
	public void preOrder(MyBinNode v) {
		
		System.out.print(v.element()+" ");
		
		if(this.hasLeft(v))
			preOrder(this.left(v));
		
		if(this.hasRight(v))
			preOrder(this.right(v));
		
		
	}
	
	public void inOrder(MyBinNode v) {
		
		if(this.hasLeft(v)) {
			System.out.print("(");
			inOrder(this.left(v));
		}
					
		System.out.print(v.element()+"");		
		
		if(this.hasRight(v)) {
			inOrder(this.right(v));
			System.out.print(")");
		}
		
	}
	
	public int postOrder(MyBinNode v) {
		
		if(this.isExternal(v))
			return Integer.parseInt((v.element().toString()));
		else {
			int x = postOrder(v.left());
			int y = postOrder(v.right());
			
			int return_val = 0;
			
			switch(v.element().toString()) {
			case "+":
				return_val = x + y;
				break;
			case "X":
				return_val = x * y;
				break;
			case "*":
				return_val = x * y;
				break;
			case "-":
				return_val = x - y;
				break;
			}
			
			return return_val;
		}
				
	}
	
	
	class TwoChildrenException extends Exception {
		
		TwoChildrenException(String msg){
			super(msg);
		}
		
	}
	
	class NotExternalException extends Exception {
		
		NotExternalException(String msg){
			super(msg);
		}
	}
	
	
	
	
	
}


```

## 실습 3

```

public class week6_main {

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		
		MyBinTree mbt = new MyBinTree("+");
		mbt.addNode("X");
		mbt.addNode("X");
		mbt.inserLeft(mbt.root().left(), "2");
		mbt.inserRight(mbt.root().left(), "-");
		mbt.inserLeft(mbt.root().left().right(), "3");
		mbt.inserRight(mbt.root().left().right(), "1");		
		mbt.inserLeft(mbt.root().right(), "3");
		mbt.inserRight(mbt.root().right(), "2");
		
		mbt.inOrder(mbt.root());
		System.out.print(" = ");
		System.out.println(mbt.postOrder(mbt.root()));

	}

}
```

- - -
 
하영국 교수님 자바 수업 


