---

title: 자료구조 시험공부(3)_Lists and Iterator
tag: data

---

## ArrayLists (aka Vectors)

operations 
*	Object get(int i)
*	Object set(int i , object e)
*	void add(int i, object e)
*	object remove(int i)
* 	int size()
* 	boolean isEmpty()

## Implementation of a Deque Using an Array List

deque를 사용해서 Array List 구현이 가능하다.

## Growable Array Implementation

## Amortized Analysis

분할 상환 분석.
최악의 경우에 대해 최악의 경우가 발생하도록 연속된 연산을 수행하고, 그 떄의 한번의 연산에 대한 평균수행시간을 분석하는 것. 
※ Asymptotic analysis- > 점근적 분석.
인풋 개수 n에 대해 알고리즘의 수행시간을 분석하는 방법.

어떤 연산이 일어난다고 가정해보자.
그 연산에 대해 "평소"에는 연산에 대한 비용이 1이라고 생각해보자. 이것만 생각하면 O(1)이라고 볼 수 있다.
하지만 정말 가끔씩 n번의 연산이 일어난다고 가정하자.

Asymtoptic analysis를 하면 최악의 경우 n번의 연산이 일어나므로 O(n)이다.

하지만 가끔씩 n번의 연산이 일어나는데, O(n)분석하기 너무 아깝다는거다.

그래서 Amortized analysis로 하면 O(1)이 된다.
대신 그냥 O(1)이 아닌 Amotized O(1)이라고 해야 한다.

다시 본론으로 돌아와서
배열의 사이즈가 n번식 더해서 커지는가 혹은 곱하기를해서 더블링이 되는가 하는 문제가 있다.

*	 Incremental Strategy Analysis
n번씩 더한다고 가정하면 . O(n)

* 	Doubling Starctegy Analysis

2씩 한다고 가정 => O(1)이 된다.

## NodeLists

operations
*	object element()
*	setElement(object e)
*	setPrev(Node p), Node getPrev()
*	setNext(Node p), Node getNext()

Generic operations
*	int size()
*	boolean isEmpty()

Accessor operations
*	Node first()
*	Node last()
*	Node prev(Node p)
*	Node next(Node p)

Update operatoins
*	set(Node p, object e)
*	addBefore(Node p, object e)
*	addAfter(Node p, object e)
*	addFirst(object e)
*	addLast(object e)
*	object remove(Node p)


## 실습 1. ArrayList를 자바로 구현해보자

(기존에 밀어주기를 구현을 안했었다. 밀어주고 받고를 구현해야 한다.)

```
package exam3;

public class MyArrayList {
	private Object []data; 
	private int index;
	private int dynamicSize;
	
	MyArrayList(int size){
		this.data = new Object[size];
		this.index = 0;
		this.dynamicSize = size;
	}
	public int size() {
		return this.index;
	}
	public boolean isEmpty() {
		return this.index == 0;
	}
	
	public Object get(int i) {
		if(i>this.index) {
			System.out.println("범위를 초과합니다.");
			return null;
		}else if(this.isEmpty()){
			System.out.println("비어있어요");
			return null;
		}
		else {
			return this.data[i];
		}
	}
	
	public Object set(int i , Object e) {
		if(i>this.index) {
			System.out.println("범위를 초과합니다.");
			return null;
		}else {
			Object temp = this.data[i];
			this.data[i] = e;
			return temp;
		}
	}
	
	public void add(int i, Object e) {
		if(i>this.index) {
			System.out.println("범위를 초과합니다.");
		}else if(this.index+1 == this.dynamicSize) {
			//새로운 배열 생성 
			Object []newArray = new Object[this.dynamicSize*2];
			
			//그대로 내용물 복사(i 전까지)
			for(int j = 0; j < this.index; j++) {
				newArray[j] = data[j];
			}
		}
		for(int k= this.index; k>i; k--) {
			this.data[k] = this.data[k-1];
		}
		this.data[i] =e;
		this.index++;
	}
	public Object remove(int i) {
		if(i>this.index) {
			System.out.println("범위를 초과합니다.");
			return null;
		}
		else if(this.isEmpty()) {
			System.out.println("비어있어요");
			return null;
		}else {
			Object temp = this.data[i];
			for(int j = i; j<this.index-1;j++) {
				this.data[j] = this.data[j+1];
			}
			this.index--;
			return temp;
		}
	}		
	
	
}


```

(이 내용을 자주 보면서 공부하자. 지워놓고 흐름 이어서 따라 칠 수 있을까지 연습하기.)

## 실습 2. MyArrayList 이용하여 stack 구현
```
package exam3;

public class MyStack {
	private MyArrayList arrayList;
	
	public MyStack(int size) {
		this.arrayList = new MyArrayList(size);
	}
	
	public void push(Object e) {
		this.arrayList.add(0, e);
	}
	
	public Object pop() {
		if(this.arrayList.isEmpty()) {
			System.out.println("리스트가 비어있어요");
			return null;
		}else {
			return this.arrayList.remove(0);
		}
	}
	public Object top() {
		return this.arrayList.get(0);
	}
	
	public boolean isEmpty() {
		return this.arrayList.isEmpty();
	}
	public static void main(String[] args) {
		
		MyStack stack = new MyStack(10);
		
		for(int i = 0 ; i < 10; i ++) {
			stack.push(i+1);
		}
		for(int i = 0 ; i < 10; i ++) {
			System.out.print(stack.pop());
		}

	}

}

```
## 실습 3. MyArrayList 이용하여 Queue 구현

```
package exam3;

public class MyQueue {
	private MyArrayList arrayList;
	
	public MyQueue(int size) {
		this.arrayList = new MyArrayList(size);
	}
	
	public int size() {
		return this.arrayList.size();
	}
	
	public boolean isEmpty() {
		return this.arrayList.isEmpty();
	}
	
	public void enqueue(Object e) {
		this.arrayList.add(0, e);
	}
	public Object dequeue() {
		if(this.arrayList.isEmpty()) {
			System.out.println("리스트가 비어있네요");
			return null;
		}else {
			return arrayList.remove(this.arrayList.size()-1);
		}
	}
	public Object front() {
		if(this.arrayList.isEmpty()) {
			System.out.println("리스트가 비어있네요");
			return null;
		}else {
			return arrayList.get(this.arrayList.size()-1);
		}
	}

	
	public static void main(String[] args) {
		MyQueue queue = new MyQueue(10);
		for(int i = 0 ; i < 10; i ++) {
			queue.enqueue(i+1);
		}
		for(int i= 0 ; i < 10; i++) {
			System.out.print(queue.dequeue());
		}

	}

}

```

## 실습 5 NodeList 구현하기.

```
package exam3_1;

public class NodeList {
	private Node header;
	private Node trailer;
	private int totalSize;
	public NodeList() {
		header = new Node();
		trailer = new Node();
		header.setNext(trailer);
		trailer.setPrev(header);
		this.totalSize = 0;
	}
	
	public int size() {
		return this.totalSize;
	}
	
	public boolean isEmpty() {
		return this.totalSize == 0;
	}
	
	public Node first() {
		return header.getNext();
	}
	
	public Node last() {
		return trailer.getPrev();
	}
	
	//Node를 찾는 함수
 	public Node Node(Object e) {
		Node x = header;
		while(x.getNext().getElement() != e) {
			x = x.getNext();
		}
		return x.getNext();
	}
 	
	public Node prev(Node p) {
		return p.getPrev();
	}
	
	public Node next(Node p) {
		return p.getNext();
	}
	
	public Node set(Node p,Object e) {
		Node temp = p;
		p.setElement(e);
		return temp;
	}
	//지정한 기존 노드 앞에 새 노드를 추가 .
	public void addBefore(Node p, Object e) {
		Node temp = new Node(e, p.getPrev(), p);
		p.getPrev().setNext(temp);
		p.setPrev(temp);
		totalSize++;
	}
	public void addAfter(Node p, Object e) {
		Node temp = new Node(e,p, p.getNext());
		p.getNext().setPrev(temp);
		p.setNext(temp);
		totalSize++;
	}
	public void AddFirst(Object e) {
		Node temp= new Node(e, this.header, this.header.getNext());
		header.getNext().setPrev(temp);
		header.setNext(temp);
		totalSize++;
	}
	public void AddLast(Object e) {
		Node temp= new Node(e, this.trailer.getPrev(), this.trailer);
		this.trailer.getPrev().setNext(temp);
		this.trailer.setPrev(temp);
		totalSize++;
	}
	public Object remove(Node p) {
		Node temp = p;
		p.getPrev().setNext(p.getNext());
		p.getNext().setPrev(p.getPrev());
		totalSize--;
		return temp.getElement();
	}
	
	public void traversList() {
		if(this.isEmpty()) {
			return;
		}
		Node temp = header;
		while(temp != null) {
			System.out.print(temp.getElement());
			System.out.print((temp.getNext()== null) ? "" :"---->");
			temp = temp.getNext();
		}
	}
	public static void main(String[] args) {
		NodeList nodeList = new NodeList();
		nodeList.AddFirst(1);
		nodeList.AddLast(2);
		nodeList.AddLast(3);
		Node temp= nodeList.Node(2);
		nodeList.remove(temp);
		Node temp2 = nodeList.Node(3);
		nodeList.addAfter(temp2, 4);
		nodeList.traversList();
	}

}

```





## NodeLists

- - -
 
하영국 교수님 자바 수업 


참고자료 Amotrized analysis 개념 참고
https://zeddios.tistory.com/60

