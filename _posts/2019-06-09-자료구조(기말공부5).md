---
layout: post
title: (자료구조)기말공부(5)Map_실습
categories: [data]
excerpt: ' '
comments: false
share: false
tags: data
date: 2019-06-09
---

## Map 복습

- 키값은 중복이 안된다
- 검색이 가능한 구조
- hash table의 key값은 데이터를 저장하는 주소값으로 활용 (associative)
- `java.util.HashMap` api 존재
- Hash table

  - Bucket array: 데이터가 저장되는 array (실습에서는 arrayList 사용)
  - Hash Function : 0~n-1 사이의 값으로 바꿔주는 함수
    - 해쉬코드 생성 : key값이 정수가 아닌 경우, 임의의 integer로 바꿔줌
    - 해쉬코드 압축 : 생성된 해쉬코드를 bucket array의 크기에 맞게 줄여줌

- Integer casting: float의 같은 경우, `Float.floatToIntBits(x)`를 사용해서 casting해준다. 나머지 byte나 short는 casting 간단히 가능
- 4byte보다 클 경우 -> 4바이트로 쪼갠뒤 summation한다 -> overflow 발생 가능 -> 그래서 가중치를 곱해서 더한다.
- 이 때 , Cyclic shift란, 곱하는 대신 shift연산 사용
- commpression function: 이제 생성했으니 압축해줘야지 -> mod 연산 사용. 이 때 MAD란 방법이 있는데 (Multiply & Add & devide)`hcomp(x) = ((a * x + b) mod p) mod N` 이 연산을 이용하면 같은 것 나올 확률이 적어. 실습에서는 `h = h % this.capacity; 활용`.
- `>>>` 비트값들을 오른쪽으로 이동시킨 후에, 왼쪽의 빈 공간은 모두 0으로 채운다

## 실습에서 주의할점

- int bucketCapacity는 최대 수용량을 뜻할 뿐. 따라서 실제로 몇개의 데이터가 들어있는지 totalCnt라는 변수가 필요함
- 생성자 생성시, new ArrayList(); 선언 이 후, for문을 거쳐서, capacity만큼 null값을 넣어서 초기화시켜준다.
- get함수 알고리즘
  1. hashfunc를 사용해서 key 값 생성
  2. 조회할 tempList생성.
  3. if tempList null이면 찾는 값 없다.
  4. 구조가 hashmap구조, 즉 separate chaining. arraylist가 각각 있고, linear하게 연결되어있는 값들을 찾는 것이므로, for문을 반복적으로 돌면서 들어있는 studentinfo와 같은지 비교
  5. string이므로 equals를 써서 같은지 비교하여 같다면 result에 담아서 리턴
- put에 있어서는 -> list가 이미 있을때, 혹은 list가 없을 때로 구분,

  - linear하게 저장되기 때문에 0번째 값의 value를 리턴해주면 된다

- 실습 2번: MyHashTabled에 data가 추가되거나 삭제될 떄마다 loadFactor를 계산하여 갱신하도록 수정
  - loadFactor는 put함수에서만 연관이 된다. 함수 시작 전, this.getLoadFactor가 this.loadFactor보다 클 경우, rehash 해준다.
  - getLoadFactor() : `return (float) this.totalCnt/this.bucketCapacity;`
  - rehash 함수 -> 매개변수 capacity만큼 bucketcapaicty 설정 후 복사해준다.

## 실습 1번 예시답안

```java
package map2;

import java.util.ArrayList;
public class MyHashTable {
	private ArrayList bucketArray; // Bucket array
	private int bucketCapacity; // Bucket size
	private int totalCnt;
	//consturctor
	MyHashTable(int initialCapacity){
		this.bucketArray = new ArrayList();
		this.bucketCapacity = initialCapacity;

		for(int i = 0 ; i <initialCapacity; i++ ) {
			this.bucketArray.add(null);
		}
	}

	//implement the following methods
	private int hashFunc(String k) {
		//해쉬코드 생성
		int h = 0 ;
		int a = 33 ;
		for(int i = 0; i < k.length(); i++) {
			h = (h<<5)| (h>>>27);
			h = (int)(k.charAt(i)*Math.pow(a,k.length()-i-1));
			// 문자열을 해쉬코드로 만들 때,각각의 char를 곱해서 만들고, 자리수를 다르게 하기 위해서, 지수 값에 변화를 줌
		}
		//해쉬코드 압축
		h = h % this.bucketCapacity;
		return h;
	}

	public int size() {
		return this.bucketCapacity;
	}

	public String get(String k) {
		int key = this.hashFunc(k);
		String result = null;
		ArrayList tempList = (ArrayList)this.bucketArray.get(key);

		if(tempList == null) {
			System.out.println("this key is empty");
		}
		else {
			for(int i=0; i < tempList.size(); i++) {
				StudentInfo temp = (StudentInfo)tempList.get(i);
				if(k.equals(temp.getStudentID())) {
					result = temp.getStudentName();
				}
			}
		}
		return result;
	}

	public String put(String k, String v) {

		StudentInfo newStudent = new StudentInfo(k,v);
		int key = this.hashFunc(k);

		ArrayList tempList = (ArrayList)this.bucketArray.get(key);

		this.totalCnt++;

		if(tempList == null) {
			//make list and put object
			ArrayList newList = new ArrayList();
			newList.add(newStudent);
			this.bucketArray.set(key, newList);
			return null;
		}
		else {
			//already exist object in key
			tempList.add(newStudent);
			StudentInfo temp = (StudentInfo)tempList.get(0);
			return temp.getStudentName();
		}
	}

	public String remove(String k) {
		int key = this.hashFunc(k);
		String result = null;

		ArrayList tempList = (ArrayList)this.bucketArray.get(key);
		if(tempList == null) {
			// no Object
			System.out.println("this key is empty");
		}
		else {
			for(int i = 0 ; i < tempList.size(); i++) {
				StudentInfo temp = (StudentInfo)tempList.get(i);
				if(k.equals(temp.getStudentID())) {
					StudentInfo removeStudent = (StudentInfo)(tempList.remove(i));
					result = removeStudent.getStudentName();
					return result;
				}
			}
		}
		return result;
	}
}

```

## 실습2번 답안

```java
package map2;

import java.util.ArrayList;

public class MyHashTable {
	private ArrayList bucketArray; // Bucket Array
	private int bucketCapacity; // Bucket Size
	private int totalCnt; //
	private float loadFactor;

	// Constructor
	MyHashTable(int initialCapacity){
		bucketArray = new ArrayList(initialCapacity);
		this.bucketCapacity = initialCapacity;
		this.totalCnt = 0;

		//init
		for(int i=0; i<initialCapacity; i++) {
			this.bucketArray.add(null);
		}
	}

	MyHashTable(int initialCapacity, float loadFactor){
		this.bucketArray = new ArrayList();
		this.bucketCapacity = initialCapacity;
		this.loadFactor = loadFactor;
		this.totalCnt = 0;

		//init
		for(int i=0; i<initialCapacity; i++) {
			this.bucketArray.add(null);
		}
	}

	public float getLoadFactor() {
		return (float)this.totalCnt / this.bucketCapacity;
	}

	public void rehash(int capacity) {
		ArrayList oldList = this.bucketArray;

		//init
		this.bucketCapacity = capacity;
		this.bucketArray = new ArrayList();
		for(int i = 0 ; i <this.bucketCapacity; i++) {
			this.bucketArray.add(null);
		}
		this.totalCnt = 0 ;

		// reinsert old bucket object into new bucket
		for(int i=0; i < oldList.size(); i++) {
			ArrayList temp = (ArrayList)oldList.get(i);
			if(temp != null) {
				for(int j = 0; j<temp.size(); j++) {
					StudentInfo tempStudentInfo = (StudentInfo)temp.get(j);
					this.put(tempStudentInfo.getStudentID(), tempStudentInfo.getStudentName());
				}
			}
		}
	}
	//Implement the following methods
	private int hashFunc(String k) {
		int h = 0 ;
		int a = 33;

		//generation
		for(int i = 0 ; i < k.length(); i++){
			h = (h << 5) | (h >>> 27);
			h = (int)(k.charAt(i)* Math.pow(a, k.length()-i-1));
		}

		//compression
		h = h % this.bucketCapacity;

		return h;
	}
	public int size() {
		return this.totalCnt;
	}
	public String get(String k) {
		//k를 검색해서 해당 value 값을 리턴하는 함수!

		int key = this.hashFunc(k);
		String result = null;
		ArrayList tempList = (ArrayList)this.bucketArray.get(key);

		if(tempList == null) {
			System.out.println("this key is empty!");
		}
		else {
			for(int i=0; i < tempList.size(); i++) {
				StudentInfo temp = (StudentInfo)tempList.get(i);
				if(k.equals(temp.getStudentID())) {
					result = temp.getStudentName();
				}
			}
		}

		return result;
	}

	public String put(String k, String v) {
		//k가 처음 들어온 거라면, entry를 insert
		//k가 중복된 거라면 ->entry insert 후 oldValue return

		if(this.getLoadFactor() > this.loadFactor) {
			this.rehash(this.bucketCapacity*2);
		}

		StudentInfo newStudent = new StudentInfo(k,v);
		int key = this.hashFunc(k);

		ArrayList tempList = (ArrayList)this.bucketArray.get(key);

		this.totalCnt++;

		if(tempList == null) {
			//make list and put object
			ArrayList newList = new ArrayList();
			newList.add(newStudent);
			this.bucketArray.set(key, newList);
			return null;
		}
		else {
			//already exist object in key
			tempList.add(newStudent);
			StudentInfo temp = (StudentInfo)tempList.get(0);
			return temp.getStudentName();
			// 변경해주는게 아니라 그냥 추가해주고 이전 value 리턴해줄 뿐
		}
	}


	public String remove(String k) {
		int key = this.hashFunc(k);
		String result = null;

		ArrayList tempList = (ArrayList)this.bucketArray.get(key);

		if(tempList == null) {
			// no object
			System.out.println("this key is empty!");
		}
		else {
			for(int i = 0 ; i < tempList.size(); i++) {
				StudentInfo temp = (StudentInfo)tempList.get(i);

				if(k.equals(temp.getStudentID())) {
					StudentInfo removeStudent = (StudentInfo) (tempList).remove(i);
					result = removeStudent.getStudentName();
					this.totalCnt--;
					}
				}
			}
		return result;
	}

	public void printHashTable() {
		System.out.println("**********HASH TABLE ***********");
		System.out.println("CAPACITY : " + this.bucketCapacity + ", Size: " + this.totalCnt + ", LoadFactor : " + this.loadFactor);

		for(int i = 0 ; i < this.bucketArray.size(); i++) {
			ArrayList tempList = (ArrayList)this.bucketArray.get(i);
			if(tempList == null) {
				System.out.println("[ 0 ]");
			}
			else {
				System.out.print("[ " + tempList.size() + " ] - ");
				for(int j = 0 ; j < tempList.size(); j++) {
					StudentInfo temp = (StudentInfo)tempList.get(j);
					System.out.print(temp.getStudentName() + " ");
				}
				System.out.println();
			}
		}
	}

}

```

하영국 교수님 자바 수업

[Zedd0202]<https://zeddios.tistory.com/237>

[덕's IT STORY]<https://itstory.tk/entry/%EB%A0%88%EB%93%9C%EB%B8%94%EB%9E%99-%ED%8A%B8%EB%A6%ACRed-black-tree>

[자바구현]
<https://www.java-tips.org/java-se-tips-100019/24-java-lang/1904-red-black-tree-implementation-in-java.html>
