
---

title:  컴퓨터구조론 (숭실대 강의 보충)
tag: class 

---
## Arithmetic for computers

음수 표현 방법 3가지
(지금은 1개로 통용되었다)

*	32 bits can only represent 2의 32승 numbers
Signed Magnitude -> -0이 존재. 부호만 존재 (최상위 존재가 부호비트)

* Represent -x as 2's complement of X

* Represent -x as 1's complement of X
	
### 곱셈 알고리즘

![image](https://user-images.githubusercontent.com/23495876/38432828-b77c15f8-3a03-11e8-8227-9681dfe9c57d.png)


![image](https://user-images.githubusercontent.com/23495876/38432943-1301a2bc-3a04-11e8-96cd-7e2d687b6073.png)

ex) 2 x 3 = 6

1. 초기 Product는 0000 0000 이다.
Multiplier 0011 이다. 즉 승수의 가장 오른쪽 비트가 1이므로 Multiplicand(피승수)와 Product를 더해준다. Multiplicand는 0000 0010이다.  

2. 그러면 Product는 0000 0010이 된다.

4. 3. shif left Multiplicand ->피승수를 left 1bit 해준면 0000 0100이 된다.
5. 
4. Multiplier를 오른쪽으로 밀어준다. 그러면 0001 이 된다.

이 과정을 한번더 반복해준다.

5. Multiplier가 0001 . 승수의 가장 오른쪽 비트가 1이므로 피승수와 product를 더해준다.
 
6. Multiplicand 0000 0100과 product 0010을 더하면 0000 0110이 된다.

7. Multiplicand를 왼쪽으로 한비트 밀면 0000 1000이 된다.

8. Multiplier를 오른쪽으로 한비트 밀면 0000이 되므로 나머지는 변하지 않는다.

(이 과정 속에서 Iteration이 돌 때마다 Multiplicand는 왼쪽으로 한 비트씩 계속 이동한다)

-> 이 과정 낭비.

#### 두 번째 버전

![2018-04-07 1 49 20](https://user-images.githubusercontent.com/23495876/38433459-e9aa3ea4-3a05-11e8-90f4-d88a4508d62c.png)

1. Mutiplier는 0011이므로 오른쪽이 1이니까 Multiplicand와 Product를 더한다 
Multiplicand는 0010이다.
그런데, Multiplicand하고 product의 윗 부분 0000 만을 더한다. 

2. 그렇게 되면 Product는 0010 0000이 된다.

3. 이전에는 Multiplicand를 shift left hand 했는데, 이번에는 Product를 shift right 한다. (상대적으로 같은 효과) 그러면 Product는 0001 0000이 된다.

4. 그 다음에 Multiplier를 오른쪽으로 shift right 해주면 0001이 된다.

이 과정을 한번 더 해준다.

5. Multiplier가 0001 이므로  Multiplicand와 Product를 더하면 

6. 0011 0000이 된다.

7. Product를 shift right하면 0001 1000이 된다.

8. Multiplier를 shift right 하면 0000이 된다.
-> Multiplicand와 shift를 더하지 않는다.

9. shift product right를 해준다 ->  0000 1100이 된다.
-> Multiplicand와 shift를 더하지 않는다.

10. Multiplier를 shift right 하면 0000 0110이 된다.

### 최종 버전 (우리 교재 프린트에 있는 버전)

처음에 Multiplier 가 4비트, 4 번째 loop

iteration 1 : Multiplier는 4비트만 의미있음 (초기 값이니까) 처음에 product 오른쪽 0000 비트 비어있다. (의미없다 위 네비트만 의미있다.)

iteration 2 : 그 다음 Multiplier 3비트 (왜냐하면 한 비트 밀었으니까) 처음에 product 오른쪽 한비트 밀었으므로 오른쪽 3비트가 비어 있다.

iteration 3 : shift해서 2개만 남았는데, 오른쪽 2비트만 비어있고

iteration 4 : shift 1 자리만. 오른쪽 1개만 비어있음.

즉 product register의 오른쪽 절반에 multiplier를 두면, 하나 빠져나갈 때, 중간결과 하나씩 늘어나니까 딱딱 맞아 떨어진다는 것이다. 별도의 레지스터, 별도의 시프터 필요 없다. 그래서 Multipler register를 없애고 저기에 시작한 것이다.

![2018-04-07 2 05 31](https://user-images.githubusercontent.com/23495876/38434121-37b8921a-3a08-11e8-8425-eba42fea605e.png)

![image](https://user-images.githubusercontent.com/23495876/38434247-adce4cba-3a08-11e8-812c-1fd7aa40ee5b.png)

1. Multiplicand는 0010, Product 0000 0011이다. product 아래 쪽에 Multiplier가 있으므로, 1로 끝나니까 두개를 더하자!

2. 두개 더하면 0010 0011이 된다. 
3. 그리고 나서 shift product right을 해주자. 그러면 0001 0001이 된다.

이 과정을 반복한다

4. Product가 0001 0001이므로 오른쪽이 1로 끝난다 그러므로 Multiplicand와 product를 더하자
5. 0011 0001이 된다. 
6. 그리고 나서 shift product right을 해준다. 그러면 0001 1000이 된다. 

7. 0001 1000이니까 오른쪽이 0으로 끝나므로 muliplier와 product를 더하지 않는다.
8. shift product right만 해주면 0000 1100이 된다.

9. 역시 0000 1100이니까 오른쪽이 0으로 끝나므로 muliplier와 product를 더하지 않는다.
10. 그리고 나서 shift product right을 해주면
0000 0110이 된다!

31분까지 들음. 내일 나눗셈 듣자.

---
 
참고자료 


컴퓨터 구조 및 설계 지음 DAVID A.PATTERSON, JOHN L>HENNESSY 

[숭실대학교 컴퓨터구조론 강의](http://www.kocw.net/home/search/kemView.do?kemId=998138)
