---

title: 자료구조 시험공부(1)
tag: data

---

## 빅오, 빅오메가, 빅세타

*	빅오 : 증가율의 상한선
*	빅오메가 : 증가율의 하한선
*	빅세타 : 증가율이 일치

## 1. Recursive

재귀호출 

정의

```
public static int recursiveFactorial(int n){
	if(n == 0) return 1;
    else return n* recursiveFactorial(n-1);
}
```


#### base Case
>	
n == 0이면 return 1;
이런게 베이스 케이스다. 베이스 케이스에서는 절대로 recursion을 쓰면 안된다.

#### Recursive calls

> 재귀 호출이 반복될수록, 재귀호출 하는 그 과정이 basecase를 향해서 진행 되어야 한다.

#### 시간복잡도, 공간복잡도 계산

`T(n) = 1 + n = O(n)`

`S(n) = 1 + n = O(n)`

### Recursion 종류

*	Linear recursions -> 한번에 호출이 한번
*	binary recursion -> 자기가 자기 자신을 두번씩 호출
*	Multiple recursion -> 자기가 자기 자신을 3번이상 호출
    

### ReverseArray(A,n)

알고리즘 보고 구현해보자.

```
package reverseingAnArray;

import java.util.Arrays;

public class Reverse {
	
	static void ReverseArray(int []a, int i, int j) {
		if(i<j) {
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
			ReverseArray(a,i+1,j-1);
		}
	}
	
	public static void main(String[] args) {
		int []Array = {1,2,3,4,5};
		
		ReverseArray(Array,0,4);
		System.out.println(Arrays.toString(Array));

	}	
}

```

## Computing Powers 

p(x,n) = x^n을 구하는걸 리커시브 하게 해보자

p(x,n) = if(n ==0) return 1; else x*p(x,n-1);

시간복잡도는 O(n)이다.

#### Intuition 요령 1
한번 호출이 일어날 때마다 n값이 일정한 크기로 줄어든다면. 그건 볼 것도 없이 O(n)이다.

#### Computing Powers by Repeated Squaring

2의 사승을 구하려면 어떻게 ?

2를 네번 곱한거지.
곱셈을 네번 하는 거야 이곱하기 이곱하기 이곱하기 이
그런데 곱셈 두번만해도 구할 수 있어 4곱하기 4

이걸 이용하자.

짝수승 구할 때 (n/2)제곱 해주고
홀수승일 때는 (x*(n-1)/2)의 제곱을 해준다.

n-1을 왜해줬을까. n이 홀수니까.

구현하기

```
package repeatedSquaring;

public class RecursiveSquaring {
	
	static int Power(int x, int n) {
		if(n == 0) { return 1;}
		if (n % 2 == 1) {
			int y = Power(x, (n-1)/2);
			return x * y * y;
		}else {
			int y = Power(x,n/2);
			return y*y;
		}
	}
	
	public static void main(String[] args) {
		System.out.print(Power(2,4));

	}

	
}
```

#### Intuition 2

재귀함수에서 recursion이 일어나는 현상이 특정한 상수배만큼 나눠진다면 일정하게, 어떤 특정한 상수값에서 멈출 때. 이런 패턴은 O(log n)으로 나타난다.

10씩 나누어진다면 베이스가 10인 로그가 된다. 중요한건 로그 형태로 줄어든다는 것.

## Tail Recursion

tail recursion 은 리커시브 호출이 어디서 일어나? 리턴하기 직전에 이러난다.

이걸 언급하는 이유. tail recursive 형태로 바꿀 수 있따면, 일반적인 반복문으로 나타내기가 쉽다. 그러면 메모리를 덜 써서 좋다.

## Binary  Recursion

BinarySum(A,i,n)
A라는 array의 n개짜리 숫자를 더해준다. bianry recursion을 이용해서.

이를 이용하면 시간복잡도는 O(n)이 된다.

## 피보나치 수열

```
package fibonacci;

public class Fibonacci {

	static int BinaryFib(int n) {
		if(n<= 1) {
			return n;
		}else {
			return BinaryFib(n-1)+BinaryFib(n-2);
		}
	}
	public static void main(String[] args) {
		System.out.println(BinaryFib(6));

	}

}

```

#### A Better Fibonacci Algorithm

```
package linearFib;

import java.util.Arrays;

public class LinearFib {
	static int[] LinearFib(int n) {
		int []Array = new int[2];
		if(n <= 1 ) {
			Array[0] = 0;
			Array[1] = n;
			return Array;
		}else {
			int []Array1 = new int[2];
			Array1 = LinearFib(n-1);
			int j = Array1[0];
			int i = Array1[1];
			Array1[1]= i+j;
			Array1[0]= i;
			return Array1;
		}
	}
	public static void main(String[] args) {
		System.out.println(Arrays.toString(LinearFib(10)));

	}

}

```

## A Better Fibonacci Algorithm(2)

 ```
 package betterFibonacci;

public class BetterFibonacci {
		static int LinearFib2(int n) {
			int prev; 
			int curr;
			int next=0;
			if(n <= 1) {return n;}
			
			prev = 0; curr =1;
			for(int i = 2; i <= n; i ++) {
				next = curr + prev;
				prev = curr;
				curr = next;
			}
			return next;
		}
	public static void main(String[] args) {
		System.out.println(LinearFib2(10));

	}

}

 ```

## Multiple Recursion

PuzzleSolve

## 실습문제 1

```
package exam1;

public class First {
	public static void main(String[] args) {
		First f= new First();
		System.out.println(f.power(5,16));
	};
	
	public long power(int x, int n) {
		if(n == 0) { return 1;}
		else if(n % 2 == 1) {
			long y = power(x, (n-1)/2);
			return x * y * y;
		}
		else {
			long y =  power(x, (n/2));
			return y*y;
		}
	}
}


```

## 실습문제 2

```
package exam1;

public class BinarySum {
	
	
	public static void main(String[] args) {
		int[] arr = new int[100];
		for(int i = 0; i <100; i++) {
			arr[i] = i+1;
		}
		BinarySum B = new BinarySum();
		System.out.println(B.BinarySum(arr, 0, 100));
	}
	public long BinarySum(int []A,int i, int n) {
		if(n == 1) {
			return A[i];
		}
		else {
			return BinarySum(A,i,(int)Math.ceil((float)n/2)) 
					+ BinarySum(A,i+(int)Math.ceil((float)n/2),n/2); 
		}
		
	}
}

```
## 실습문제 3

```
package linearFib;

import java.util.Arrays;

public class LinearFib {
	public long[] LinearFib(long n) {
		long []Array = new long[2];
		if(n <= 1 ) {
			Array[0] = n;
			Array[1] = 0;
			return Array;
		}else {
			long []arr = new long[2];
			arr = LinearFib(n-1);
			long temp = arr[0];
			arr[0] += arr[1];
			arr[1] = temp;
			return arr;
		}
	}
	public static void main(String[] args) {
		LinearFib L = new LinearFib();
		long[]result = L.LinearFib(50);
		System.out.println(Arrays.toString(result));

	}

}

```


-> 내가 한 거 틀린거 없어. 맞게 잘했어.





- - -
 
