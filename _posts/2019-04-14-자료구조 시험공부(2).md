---

title: 자료구조 시험공부(2)_stack,Queue
tag: data

---

## stack

push/pop/top/size/isEmpty

#### Array-based Stack

#### Parenthese Mactching Algorithm

## Queue

enqueue,dequeue,front,size,isEmpty

#### Array-based Queue

(To implement a circular array, we can use the modulo operator)

## Deque

(we can use a NodeList to implement a deque efficiently)

## 실습 1,2

stack 인터페이스를 이용하여 arraySyack 클래스를 구현
그 뒤 사칙연산 및 괄호가 포함된 수식을 입력 받아서 수식의 순서를 역수로 변환하여 화면에 출력하기

`stack.java`

```
package exam2;

import exam2.ArrayStack.EmptyStackException;
import exam2.ArrayStack.FullStackException;

public interface Stack { 
	public int size();
	public boolean isEmpty(); public char top() throws EmptyStackException;
	public char push(char o) throws FullStackException;
	public char pop() throws EmptyStackException; 
}
```

`arrayStack.java`

```
package exam2;

public class ArrayStack implements Stack {
	public class EmptyStackException extends Exception{
		EmptyStackException(){
			System.out.println("비어있어요");
		}
	}
	public class FullStackException extends Exception{
		FullStackException(){
			System.out.println("꽉차있어요");
		}
	}

	private int top;
	private char []data;
	private int ArraySize;
	
	ArrayStack(int size){
		this.ArraySize = size;
		this.top = -1;
		this.data = new char[size];
	}
	
	@Override
	public int size() {
//		return this.totalSize;
		return this.top+1;
	}

	@Override
	public boolean isEmpty() {
//		return this.totalSize == 0;
		return this.top == -1;
	}

	public char top() throws EmptyStackException{
		if(isEmpty()) {
			throw new EmptyStackException();
		}else {
			return this.data[top];
		}	
	}

	@Override
	public char push(char o) throws FullStackException {
		if(this.size() == ArraySize-1) {
			throw new FullStackException();
		}
		else {
			this.top++;
			this.data[this.top] = o;
			return o;
		}
	}

	@Override
	public char pop() throws EmptyStackException{
		if(isEmpty()) {
			throw new EmptyStackException();
		}
		char temp = this.data[this.top];
		top--;
		return temp;
	}
	
	
}

```

`Main`
```
package exam2;

import java.util.Scanner;

import exam2.ArrayStack.EmptyStackException;
import exam2.ArrayStack.FullStackException;

public class Main {

	public static void main(String[] args) throws FullStackException, EmptyStackException {
		ArrayStack stack= new ArrayStack(100);
		Scanner stdIn = new Scanner(System.in);
		
		System.out.println("입력하세요");
		String s = stdIn.next();
		
		//나는 다 입력받아서 처리를 해줬었는데 입력을 받으면서 처리를 해주면 훨씬 간단하다.
		

		for(int i = 0 ; i < s.length(); i++) {
			char temp = s.charAt(i);
			
			if(temp == '(') {
				stack.push(')');
			}else if(temp == ')') {
				stack.push('(');
			}else {
				stack.push(temp);
			}
		}
		while(!stack.isEmpty()) {
			System.out.print(stack.pop());
		}

	}

}

```

## 실습 3번
두 개의 스택을 이용하여 Queue를 구현하고, a~z까지이ㅡ 문자를 Queue에 저장했다가 제거하면서 화면에 출력하는  Java 프로그램을 작성하시오

기존에 내가 뭘 못했는지 알 수 있었다.

`Queue.java`
```
package exam2;

import exam2.ArrayStack.EmptyStackException;
import exam2.ArrayStack.FullStackException;

public interface Queue {
	public int size();
	public boolean isEmpty(); 
	public char front() throws FullStackException, EmptyStackException;
	public void enqueue(char o) throws FullStackException, EmptyStackException;
	public char dequeue() throws FullStackException, EmptyStackException;
}

```

`stackQueue.java`

```
package exam2;

import exam2.ArrayStack.EmptyStackException;
import exam2.ArrayStack.FullStackException;

public class StackQueue implements Queue {

	private ArrayStack inStack;
	private ArrayStack outStack;
	
	public StackQueue(int size) {
		this.inStack = new ArrayStack(size);
		this.outStack = new ArrayStack(size);
	}
	
	@Override
	public int size() {
		// TODO Auto-generated method stub
		return this.inStack.size() + this.outStack.size();
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return this.inStack.isEmpty() && this.outStack.isEmpty();
	}

	@Override
	public char front() throws FullStackException, EmptyStackException {
		while(!this.inStack.isEmpty()) { //instack이 다 빌 때까지
			this.outStack.push(this.inStack.pop()); //outStack으로 옮겨
		}
		return this.outStack.top();
	}

	@Override
	public void enqueue(char o) throws FullStackException, EmptyStackException {
		while(!this.outStack.isEmpty()) { // outStack 이 빌 때까지
			this.inStack.push(this.outStack.pop());  
			// front 하면 죄다 outstack에 가있으니까  다시 넣어주는거야
		}
		this.inStack.push(o);
	}

	@Override
	public char dequeue() throws FullStackException, EmptyStackException {
		while(!this.inStack.isEmpty()) {
			this.outStack.push(this.inStack.pop());
		}
		return this.outStack.pop();
	}
	
}

```

`main2.java`
```
package exam2;

import exam2.ArrayStack.EmptyStackException;
import exam2.ArrayStack.FullStackException;

public class Main2 {

	public static void main(String[] args) throws FullStackException, EmptyStackException {
		StackQueue Queue = new StackQueue(100);
		
		for(char i = 'a'; i <='z'; i++) {
			Queue.enqueue(i);
		}	
		for(char i = 'a'; i <='z'; i++) {
			System.out.print(Queue.dequeue() + " ");
		}

	}

}

```

기존에 실습 3번 문제를 푸는데 있어서 front를 할 때는 outstack으로 다 몰아줘야한다는 것과,
 enqueue를 할 때는 다시 outstack에 있는 것을 instack으로 몰아준 뒤에 enqueue를 해줘야한다는 것으 기억하자.


- - -
 
하영국 교수님 자바 수업 