---
layout: post
title: (자료구조)Heap
categories: [data]
excerpt: ' '
comments: false
share: false
tags: data
date: 2019-05-02
---

## Heaps(Complete binary trees)

1.  prioirty Queue 시간 복잡도 계산해보면 insertion, select 모두 n^2
2.  insertion, remove 하는데 n time이 소요된다.
3.  조금 더 빨리 할 수 없나?
4.  힙이라는 자료 구조 이용하면 insert하고 remove를 logn time에 할 수 있다.

### heap data Structure

- 2가지 조건 만족
- Complete binary tree property : 왼쪽부터 오른쪽으로 차곡차곡 쌓아가는 모양. from left to right,
- Heap-order property : 부모노드의 키값이 자신의 키값 보다 작다.

### Complete binary Tree

- tree에서 가장 중요한 노드 -> root node
- lastNode도 root노드 만큼 중요

### Heap-order property

- 아래로 내려갈 수록 부모노드의 키값은 자식 보다 작아야한다
- 가장 작은 키는 Root
- Reverse heap -> 가장 큰 값이 루트에

### Height of a Heap

- 힙의 크기가 h라면, h는 항상 logn 이다.

### Complete Binary Tree operations

- 임의의 노드 추가, 삭제 불가.
- `node add(Object e)` : adds a new last node
- `Object remove()` : revmoses the alst node

### The Heap and the Other Tree Data Structures

![No Image](/assets/posts/20190502/1.png)

- Tree <- Binary Tree <- Complete Binary Tree <- Heap
- 힙도 일종의 트리다.
- 객체지향적 관점에서 보면 상속 관계

### Implementation of a PQ with a Heap

- 키값이 가장 작은, 즉 우선순위가 가장 높은 노드가 루트에 위치
- 힙에 데이터를 저장하고 루트에 있는 값을 항상 가져오면 PQ 구현 가능

### Insertion Into a Heap

1. Add a new last node (heap의 add operation 사용)
2. up-heap bubbling Algorithm . key를 확인해서 노드를 위로 올려준다

### Up-heap Bubbling

- heap-order를 지켜주는 것
- 부모 노드와 자식 노드 key 비교
- logn time

### Removal from a Heap

1. 루트노드와 라스트 노드를 바꿔준다.
2. 라스트 노드 제거
3. 루트에 있는 노드의 heap-order를 맞춰준다 -> down-heap bubbling

### Down-heap bubbling

- 루트에 있는 key를 아래의 leaf node와 비교하며 순서를 맞춰줌
- 왼쪽? 오른쪽 중 작은 쪽으로 가야한다. 그게 좋다.

### Updating the Last Node

- 라스트 노드를 찾는 방법

1. 이전에 삭제된 노드에서 출발한다.
2. 삭제된 노드가 있던 서브트리가, 오른쪽에 올 때까지 위로 올라간다
3. 루트일 때는 왼쪽으로 한번 간다. 그리고 계속 오른쪽으로 간다.
4. ※ 왼쪽 끝에 도달했을 경우, 바로 이전 레벨의 오른쪽으로 간다.

### Analysis of Heap

- insert : O(log n) = locating new last node: O(log n) + adding last node O(1) + up-heap bubbling : O(log n)

- removeMin : O(log n) = deleting last node: O(1) + down-heap bubbling: O(log n) + updating last node : O(log n)

- ※ removeMin의 경우 updating last node, 즉 last node를 바꿔주는 데 걸리는 시간을 말한다. (last node를 찾아가야 하니까.)

## Heap sort

- 힙을 이용해서 정렬
- 힙을 가지고 PQ를 만들었다면 n번 insert, n번 remove -> 토탈 nlog n time
- 두 개의 키 값을 비교해서 정렬하는 방식 -> 아무리 빨라도 nlog n 보다 빠를 수 없다.
- ※ radix sort -> n time. 그러나 항상 쓸 수는 없다.

### Array-Based Heap

- array통해 힙 구현 -> 효율성이 높다
- array통해 binary tree 구현 -> 공간복잡도가 안좋음
- but Heap의 경우 낭비하는 공간x
- 또한 찾기가 좋다. logn을 왔다갔다할 필요가 없다.
- add는 맨 뒤에 붙여주고, remove는 맨 뒤부터 삭제해주면 된다.

### In-place Sort(1)

- array 하나만 가지고 가능
- reverse order comparator를 쓴다고 가정
- 부모노드 비교 -> 나의 인덱스값/2하고 해당 위치에 있는 값과 비교

### In-place Sort(2)

- 루트는 바로 삭제 못하니, 루트와 가장 마지막을 바꾼다.
- 그리고 나서 마지막 노드 삭제
- down-heap을 해준다.
- 이 과정 반복하면 정렬.

### Building a Heap

- 힙을 만드는 과정-> 1) successive insertion 2) Bottom-up construction
- 가장 직관적 -> 노드를 하나씩 추가 => n개의 노드를 n번 insert : nlogn time
- 기존 두개의 힙을 합쳐서 새로운 힙 하나로 merging한 뒤, bottom-up방식 =>n time

### Mergin Two Heaps

- 두 개의 힙을 합치는 과정
- 추가적인 키가 더 필요
- 그래서 키를 하나 추가하고 두개를 붙인다(ex 3개 노드로 구성된 힙 + 3개 노드로 구성된 힙 + 1 키)

### Example

- Bottom-up 방식 제약사항
- 키가 1개, 3개, 7개, 15개 즉 2의 ^(n-1)일 때 조건 만족

1.  15개라면 : 8개 집어서 바닥에 깐다
2.  4개 집어서 위로 쌓고 down heap
3.  2개 집어서 위로 쌓고 down heap
4.  1개 집어서 쌓고 down heap

### Adaptable Prioirty Queue

- 일종의 PQ
- 특수한 기능이 추가된 자료구조

### Motivating Examples

- 비행기 상황 가정
- prioirty queue에서 제거가 일어나면, 즉 임의의 노드 제거 기능 (특정 entry 삭제)
- 마일리지가 없는줄 알았는데 있네 -> 우선순위 조정기능
- 항공권의 이름이 달라졌어 -> PQ에서 data value를 바꿔주는 기능

### Adaptable PQs

- `entry remove(entry e)`
  - PQ에서 entry 를 지우고 지운 entry를 반환한다.
- `Object replaceKey(entry e, Object k)`
  - entry의 key를 k로 바꾸고 e를 반환해준다.
  - k가 다른 키와 비교할 수 없는 키라면,에러가 발생한다.
- `Object replaceValue(entry e, Object v)`
  - e의 value를 v로 교환하고 e의 이전 value를 반환
- 엔트리만 저장하면 되는게 아니라, 엔트리를 저장하고 있는 노드까지 삭제를 해줘야 한다.
- 헤더에서부터 엔트리의 위치를 찾기가 어려우니, 백링크를 달아준다. 이런 엔트리를 location-aware-entry라고 한다

### List Implementation

- A locatoin-aware entry는 저장하고 있어야해
  - A key,
  - A value, and
  - A back link to a node of the underlying list

### Heap Implementation

- 힙에서도 마찬가지다.

![No Image](/assets/posts/20190502/1.png)

---

하영국 교수님 자바 수업
