---
layout: post
title: (자료구조)기말공부(6)MyBST
categories: [data]
excerpt: ' '
comments: false
share: false
tags: data
date: 2019-06-10
---

## BinarySearchTree복습

- 순서화된 딕셔너리 저장하기 좋은 자료구조
- MyBinTree는 그냥 이진트리라면
- BinarySearchTree는 completeBinaryTree + key값에 대한 규칙 -> 이건 힙이잖아
- heap과 binarySearchTree의 차이
  - 모두 이진트리라는 점에서는 같음
  - 노드값이 다르게 구성됌
  - 힙은 각 노드의 값이 자식보다 큰 반면
  - 이진 탐색트리는 왼쪽 자식 노드가 제일 작고 부모가 그 다음으로 크며 오른쪽 자식 ㄴ드가 가장 큰 값을 가짐
  - 힙은 우선순위 정렬에, 이진탐색트리는 탐색에 강점을 지닌 자료구조다.

#### Max heap

![No Image](/assets/posts/20190610/1.png)

#### BST

![No Image](/assets/posts/20190610/2.png)

### method 복습

- `private MyBinNode nextNode(MyBinNode v)` : inOrder 순서상 v의 다음번 노드를 반환 ->
  1. 우선 inOrder 함수를 구현하자 (?-> 이게 어디에 쓰이지 ?)
  2. `inOrderNextNode(ArrayList al, MyBinNode v)` 구현 -> 어떤 함수냐면, 기존에는 inOrder를 출력하는 용도였지만 지금은 출력이 아니라 ArrayList al에 출력값을 add한다.
  3. nextNode를 구현하는 방법은 2가지다
     1. InOrder 를 이용하는 방법(재귀)
     2. while를 이용하는 방법
- `Object find(Object k)` 작성

  1. 반복문 -> null이면 break, (외부노드 발견), 찾으면 -> result에 넣고 break;, key가 temp보다 작으면 left -> key가 temp보다 크면 right

- `ArrayList findAll(Object k)`작성

  - inOrderfindAll 함수가 필요 -> 매개변수로 Object k를 넘겨줌

- `Object insert(Object k)`
  - while문을 활용하여, 같은 key를 만나면 -> 좌, 우, (같은 키 없음 breakl)로 반복
  - key가 temp보다 크면 -> 오른쪽이 비어있으면 오른쪽으로 추가. 아니라면 계속 탐색하기 위해서 `temp = temp.right();`
  - key가 temp보다 작으면 ->left가 비어있느지 보고 비어있으면 거기에 추가. 아니라면 계속 탐색 `temp = temp.left();`
- `Object remove(Object k) throws TwoChildrenException`

- 1. MyBinNode temp에 super.root();를 넣어두고,
- 2. return할 Object result 선언
- 3.  while(true) 돌면서

  - 1.  temp == null 이면 break
  - 2.  temp.element() == k이면

    - (1). internal both child -> find nextnode & copy & remove
    - (2). case - one child & external

  - 3.  case - key is bigger than temp
  - 4.  case - key is smaller than temp

- 4. result == null : Can't remove key!

## 순서

#### 1. inOrder 함수 구현

```java
public void inOrder(MyBinNode v) {

		if(super.hasLeft(v)) {
			inOrder(super.left(v));
		}
		System.out.println(v.element()+" ");
		if(super.hasRight(v)) {
			inOrder(super.right(v));
		}

	}
```

#### 2. inOrderNextNode 구현

```java
public void inOrderNextNode(ArrayList al, MyBinNode v) {
		if(super.hasLeft(v)) {
			inOrderNextNode(al,super.left(v));
		}
		al.add(v);

		if(super.hasLeft(v)) {
			inOrderNextNode(al,super.right(v));
		}
	}
```

#### 3.1 (inOrder 활용한 ) nextNode 구현

```java
private MyBinNode nextNode(MyBinNode v) {
	//inOrder 순서상 v노드의 다음번 노드를 반환
		ArrayList inOrderList = new ArrayList();
		this.inOrderNextNode(inOrderList, v);
		MyBinNode result = null;

		for(int i = 0 ; i < inOrderList.size(); i++) {
			MyBinNode temp = (MyBinNode)inOrderList.get(i);
			result = (MyBinNode)inOrderList.get(i+1);
			break;
		}
	}
```

#### 3.2 while문 활용한 nextNode구현

```java
private MyBinNode nextNode2(MyBinNode v) {
		MyBinNode result = null;
		// nextNode는 오른쪽에 있으니까.
		if(super.hasRight(v)) {
			MyBinNode temp = v.right();

			while(true) {
				if(super.hasLeft(temp)) {
					temp = temp.left();
				}
				else {
					result = temp;
					break;
				}
			}
		}
		else {
			System.out.println("No Next Node");
		}
		return result;
	}
```

#### 4. find method

```java
public Object find(Object k){
	// k값을 갖는 키 객체를 탐

		MyBinNode temp = super.root();
		Object result = null;

		while(true) {
			if(temp == null) break;
			if((int)temp.element() == (int)k) {
				//find key
				result = temp;
				break;
			}
			else if((int)temp.element() < (int)k) {
				//case - key is bigger than temp
				temp = temp.right();
			}
			else {
				//case - key is smaller than temp
				temp = temp.left();
			}
		}
		if(result == null) {
			System.out.println("Can't find Key!");
		}
		else {
			System.out.println("FIND KEY : " + ((MyBinNode)result).element());
		}
		return result;
	}
```

#### 5. inOrderfindAll()구현

```java
	public void inOrderfindAll(ArrayList al, MyBinNode v, Object k) {
		if(this.hasLeft(v)) {
			inOrderfindAll(al,this.left(v),k);
		}
		if((int)v.element() == (int)k) {
			al.add(k);
		}

		if(this.hasRight(v)) {
			inOrderfindAll(al,this.right(v),k);
		}

	}
```

#### 6. findAll()구현

```java
public ArrayList findAll(Object k) {
	//동일한 k값을 갖는 키객체를 모두 탐색
		ArrayList findList = new ArrayList();

		//using inorder traversal
		this.inOrderfindAll(findList, this.root(), k);
		System.out.println("Find ALL KEY : " + (int)k + " , COUNT :"  + findList.size());

		return findList;
	}
```

#### 7. insert() 구현

```java
public Object insert(Object k) {

		MyBinNode temp = this.root();

		while(true) {

			if((int)temp.element() == (int)k) {
				// case - key is already exist in tree
				if(super.hasLeft(temp)) {
					temp = temp.left();
				}
				else if(super.hasRight(temp)) {
					temp = temp.right();
				}
				else {
					System.out.println("Same Key Exception Occurs - same key no child !");
					break;
				}
			}
			else if((int)temp.element() < (int)k) {
				// case - key is bigger than temp
				if(!super.hasRight(temp)) {
					// insert do it
					super.inserRight(temp, k);
					break;
				}
				else {
					// continue search
					temp = temp.right();
				}
			}
			else {
				// case - key is smaller than temp
				if(!super.hasLeft(temp)) {
					// insert do it
					super.inserLeft(temp, k);
					break;
				}
				else {
					// continue search
					temp = temp.left();
				}
			}
		}


		return k;
	}
```

#### 8. remove 함수 구현

```java
	public Object remove(Object k) throws TwoChildrenException{
		MyBinNode temp = this.root();
		Object result = null;

		while(true) {
			if(temp == null) break;

			if((int)temp.element() == (int)k) {
				// find key and remove

				if(super.hasLeft(temp) && super.hasRight(temp)) {
					// case - internal both child

					// find next node & copy & remove
					MyBinNode nextNode =this.nextNode(temp);
					temp.setElement(nextNode.element());
					MyBinNode nextNodeParent = (MyBinNode)nextNode.parent();
					result = super.remove(nextNode);
				}
				else {
					//case - one child & external
					result = super.remove(temp);
				}
				break;
			}
			else if((int)temp.element() < (int)k) {
				// case - key is bigger than temp
				temp = temp.right();
			}
			else {
				// case - key is smaller than temp
				temp = temp.left();
			}
		}
		if(result == null){
			System.out.println("Can't remove Key !");
		}
		return result;
	}
}
```

#### 8. Main

```java
public class Main {

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub

		// example 1
		MyBST mbst = new MyBST(new Integer(6));
		System.out.println( mbst.insert(new Integer(2)) );
		System.out.println( mbst.insert(new Integer(9)) );
		System.out.println( mbst.insert(new Integer(1)) );
		System.out.println( mbst.insert(new Integer(4)) );
		System.out.println( mbst.insert(new Integer(8)) );
		System.out.println( mbst.insert(new Integer(9)) );


		System.out.println("-----------------------------------------------------");
		mbst.inOrder(mbst.root());
		System.out.println();
		System.out.println("-----------------------------------------------------");
		// example 2
		// System.out.println( ((MyBinNode)mbst.find(new Integer(8))).element() );
		mbst.find(new Integer(8));
		mbst.find(new Integer(3));
		System.out.println(" ");
		System.out.println( mbst.insert(new Integer(3)) );
		System.out.println( mbst.insert(new Integer(7)) );
		System.out.println( mbst.insert(new Integer(9)) );
		System.out.println( ((MyBinNode)mbst.remove(new Integer(1))).element() );
		System.out.println( ((MyBinNode)mbst.remove(new Integer(4))).element() );
		System.out.println( ((MyBinNode)mbst.remove(new Integer(6))).element() );
		mbst.find(new Integer(3));
		mbst.find(new Integer(6));
		mbst.findAll(new Integer(9));
		System.out.println("-----------------------------------------------------");


		// example 3
		mbst.inOrder(mbst.root());

	}

}
```

---

하영국 교수님 자바 수업

heap과 BinarySearchTree비교<https://ratsgo.github.io/data%20structure&algorithm/2017/09/27/heapsort/>
binary Search Tree 원리 <https://yaboong.github.io/data-structures/2018/02/12/binary-search-tree/>
