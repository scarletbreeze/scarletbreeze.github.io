---

title: SparseMatrix
tag: data

---

### 프로그램 3.4 희소행렬 프로그램 #2

```
#include <stdio.h>
#define ROWS 3 // 행의 개수
#define COLS 3 // 열의 개수

// 희소 행렬 덧셈 함수
void sparse_matrix_add1(int A[ROWS][COLS], int B[ROWS][COLS], int C[ROWS][COLS]) // C = A + B
{
    int r,c;
    for(r = 0; r < ROWS; r++)
        for(c=0; c < COLS; c++)
            C[r][c] = A[r][c] + B[r][c];
}

// 주함수

int main()
{
    int array1[ROWS][COLS] = {{2,3,0}, {8,9,1}, {7,0,5}};
    int array2[ROWS][COLS] = {{1,0,0}, {1,0,0}, {1,0,0}};
    int array3[ROWS][COLS];
    sparse_matrix_add1(array1,array2,array3);
}

```

#### 프로그램 3.5 희소행렬 프로그램 #2 
이해 안가서 다시 공부해야한다.


```
#include <stdio.h>
#include <stdlib.h>
#define ROWS 3
#define COLS 3
#define MAX_TERMS 10
typedef struct {
    int row;
    int col;
    int value;
}element;

typedef struct SparseMatrix{
    element data[MAX_TERMS];
    int rows; // 행의 개수
    int cols; // 열의 개수
    int terms; // 항의 개수
}SparseMatrix;

// 희소 행렬 덧셈 함수
// c = a + b
SparseMatrix sparse_matrix_add2(SparseMatrix a, SparseMatrix b)
{
    SparseMatrix c;
    int ca=0, cb=0, cc=0; // 각 배열의 항목을 가리키는 인덱스
    // 배열  a와 배열 b의 크기가 같은 지를 확인
    if(a.rows!= b.rows || a.cols != b.cols){
        printf("희소 행렬 크기 에러 \n");
        exit(1);
    }
    c.rows = a.rows;
    c.cols = a.cols;
    c.terms = 0;
    
    while(ca < a.terms && cb < b.terms){
        //각 항목의 순차적인 번호를 계산한다
        int inda = a.data[ca].row * a.cols + a.data[ca].col;
        int indb = b.data[cb].row * b.cols + b.data[cb].col;
        if( inda < indb){
            //a 배열 항목이 앞에 있으면
            c.data[cc++] = a.data[ca++];
        }
        else if(inda == indb){
            //a와 b가 같은 위치
            if((a.data[ca].value+
                b.data[cb].value)!=0){
                c.data[cc].row=a.data[ca].row;
                c.data[cc].col = a.data[ca].col;
                c.data[cc++].value = a.data[ca++].value+b.data[cb++].value;
            }
            else{
                ca++;
                cb++;
            }
        }
        else
            // b 배열 항목이 앞에 있음
            c.data[cc++] = b.data[cb++];
        }
        //배열 a나 b에 남아있는 항들을 배열 c로 옮긴다.
    for(; ca < a.terms;)
        c.data[cc++] = a.data[ca++];
    for(; cb < b.terms;)
        c.data[cc++] = b.data[cb++];
    c.terms = cc;
    return c;
}

int main()
{
    SparseMatrix m1 = {{{1,1,5}, {2,2,9}}, 3,3,2};
    SparseMatrix m2 = {{{0,0,5}, {2,2,9}}, 3,3,2};
    SparseMatrix m3;
    
    m3 = sparse_matrix_add2(m1,m2);
}

```


---
