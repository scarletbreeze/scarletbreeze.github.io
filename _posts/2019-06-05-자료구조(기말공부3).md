---
layout: post
title: (자료구조)기말공부(3)_BinaryTree
categories: [data]
excerpt: ' '
comments: false
share: false
tags: data
date: 2019-06-05
---

## Binary Tree

- Internal node : operator로
- External node : Operand로 잘 스인다.
- isEmpty? -> Tree 전체 사이즈가 비었는지 확인
- root함수 -> MyNode를 MyBinNode가 상속 받았으므로,즉 MyNode가 MyBinNode의 상위 클래스 이므로 형변환이 가능하다.
- addNode부터 바이너리 트리의 규칙 맞게 정해줘야해.
  _ left,right 자식 둘다 존재 -> addNode 불가능
  _ left 자식 1개 존재 -> 오른쪽에 추가
  _ right 자식 1개 존재 -> 왼쪽에 추가
  _ 자식 둘다 비어있을 때 -> 둘다에 넣어줘
- insert할 때, 예시코드는 갱신이 아닌 검사해서 갯수가 이미 차있으면 갱신이 안되도록 했다.
- insert 함수 구현한 뒤, addNode 함수 만들고, addNode 구현 시, return 값 넣어주기
- remove하고 child에 null값 넣어줘야할까?
  - remove 할 때 parent연결이 중요
  - 따라서 삭제할 노드가 left node인지, right node인지 기억하고 있어야 한다.
  - 삭제할 노드의 왼쪽 혹은 오른쪽 자식 기억
  - 삭제할 노드의 부모와 위에서 기억한 자식 연결
  - 자식의 부모로 삭제할 노드의 부모 연결
- ![No Image](/assets/posts/20190605/1.png)
- attach함수 : v에다가 t1과 t2연결, 이 때 v가 외부노드일 때만 사용 가능
- 후위순회 사용하여 -> 수식 계산하기 - if 외무노드이면 그대로 출력 - else 내부노드이면 leftchild를 x로놓고 - rightchild를 y로 놓고 - operator를 통해 계산한 값을 리턴해준다.
- java 라이브러리나 유저가 만든 모든 클래스는 "Object" 클래스를 부모클래스로 상속 받아서 사용한다
- toString() : 객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드
- Integer.parseInt(String s) : 숫자형의 문자열을 인자값으로 받으면 해당 값을 10진수의 Integer 형으로 반환 - ("2018", 8) 이렇게 하면 8진수로 해당 숫자를 바꿔준다
- isExternal 함수를 작성시, 매개변수 MyBinNode v의 degree가 0이 아니다로 해선 안되고, hasLeft와 hasRight써줘야 한다. 왜냐하면 NULL로 MyBinNode를 채워줬기 때문이다.

#### addNode

```java
public MyBinNode addNode(Object e) {
		MyBinNode return_node = null;
		//둘 다 차있을 때,
		if(this.hasLeft((MyBinNode)super.root()) && this.hasRight((MyBinNode)super.root())){
			System.out.println("둘다 차있네요 ");
		}
		//왼쪽이 있을 때
		else if(this.hasLeft((MyBinNode)super.root())) {
			return_node = this.insertRight((MyBinNode) super.root(), e);

		}
		//오른쪽이 있을 때
		else if(this.hasRight((MyBinNode)super.root())) {
			return_node = this.insertLeft((MyBinNode) super.root(), e);
		}
		//둘다 없을 때
		else {
			return_node = this.insertLeft((MyBinNode) super.root(), e);
		}
		return return_node;
	}
```

### remove

```java
public MyBinNode remove(MyBinNode v) throws TwoChildrenException{
		MyBinNode parent = (MyBinNode)v.parent();

		int idx = 0;
		if(this.left(parent) == v) {
			//v는 부모의 왼쪽 노드
			idx = 0;
		}
		else {
			//v는 부모의 오른쪽 노드
			idx = 1;
		}

		//둘 다 차있을 때, ->  삭제가 안되도록 !
		if(this.hasLeft((MyBinNode)super.root()) && this.hasRight((MyBinNode)super.root())){
			// two children
			throw new TwoChildrenException("TwochildException!!");
		}
		//왼쪽이 있을 때
		else if(this.hasLeft((MyBinNode)super.root())) {
			MyBinNode children = (MyBinNode)v.children().get(0);
			parent.children().set(idx, children);
			children.setParent(parent);

		}
		//오른쪽이 있을 때
		else if(this.hasRight((MyBinNode)super.root())) {
			MyBinNode children = (MyBinNode)v.children().get(1);
			parent.children().set(idx, children);
			children.setParent(parent);
		}
		//둘다 없을 때
		else {
			parent.children().set(idx, null);
		}
		return v;
	}
```

### PostOrder

```java

```

### MyBinNode.java

```java
package tree;

import java.util.ArrayList;

public class MyBinNode extends MyNode  {
	//constructors

	public MyBinNode(){
		super();
	}
	public MyBinNode(Object e){
		super(e);
	}

	public MyBinNode(Object e, MyNode p, ArrayList<Object> c) {
		super(e,p,c);
	}

	//implement the following methods

	public MyBinNode left() {
		return (MyBinNode) this.children().get(0);
	}
	public MyBinNode right() {
		return (MyBinNode) this.children().get(1);
	}
	public void setLeft(MyBinNode v) {
		this.children().set(0, v);
	}
	public void setRight(MyBinNode v) {
		this.children().set(1, v);
	}

}

```

### MyBinTree class 작성

```java
package tree;

import java.util.ArrayList;

public class MyBinTree extends MyTree {
//	private MyNode root;
//	private int TreeSize;
	public MyBinTree() {
		super();
	}

	public MyBinTree(Object e) {
		super(e);
	}

	// implements the following methods

	// 트리 전체 사이즈가 비었다고.
	public boolean isEmpty() {
		return super.size() == 0;
	}

	public boolean isRoot(MyBinNode v) {
		return super.root() == v;
	}

	public boolean isInternal(MyBinNode v) {
		return !isExternal(v);
	}

	public boolean isExternal(MyBinNode v) {
		if (!this.hasLeft(v) && !this.hasRight(v)) {
			return true;
		} else
			return false;
	}

	public MyBinNode root() {
		return (MyBinNode) super.root();
	}

	public MyBinNode parent(MyBinNode v) {
		return (MyBinNode) v.parent();
	};

	public MyBinNode left(MyBinNode v) {
		return (MyBinNode) v.children().get(0);
	};

	public MyBinNode right(MyBinNode v) {
		return (MyBinNode) v.children().get(1);
	};

	public boolean hasLeft(MyBinNode v) {
		return v.children().get(0) != null;
	}

	public boolean hasRight(MyBinNode v) {
		return v.children().get(1) != null;
	}

	// addRoot 기존의 루트 바꾼다 보다는 새로운 루트 생성. 새로 생긴 루트 반환
	public MyBinNode addRoot(Object e) {
		MyBinNode temp = (MyBinNode) super.addRoot(e);
		return temp;
	};

	// root의 child로 넣는다. 새로 생성한 노드 반환
	public MyBinNode addNode(Object e) {

		MyBinNode return_node = null;

		if (hasLeft((MyBinNode) super.root()) && hasRight((MyBinNode) super.root())) {
			// 2 children exist
			System.out.println("Can't add Node because Two Children exist !");
		} else if (hasLeft((MyBinNode) super.root())) {
			// left children exist - addNode to right
			return_node = this.insertRight((MyBinNode) super.root(), e);
		} else if (hasRight((MyBinNode) super.root())) {
			// right children exist - addNode to left
			return_node = this.insertLeft((MyBinNode) super.root(), e);
		} else {
			// children is empty
			return_node = this.insertLeft((MyBinNode) super.root(), e);
		}

		return return_node;
	}

	public MyBinNode insertLeft(MyBinNode v, Object e) {
		MyBinNode mbn = null;
		if (!this.hasLeft(v)) {
			mbn = (MyBinNode) super.setChild(v, 0, e);
		}
		return mbn;
	}

	public MyBinNode insertRight(MyBinNode v, Object e) {
		MyBinNode mbn = null;
		if (!this.hasRight(v)) {
			mbn = (MyBinNode) super.setChild(v, 1, e);
		}
		return mbn;
	}

	public Object replace(MyBinNode v, Object e) {
		Object temp = v.element();
		v.setElement(e);
		return temp;
	}

	public MyBinNode remove(MyBinNode v) throws TwoChildrenException {
		MyBinNode parent = (MyBinNode) v.parent();

		int idx = 0;
		if (this.left(parent) == v) {
			// v는 부모의 왼쪽 노드
			idx = 0;
		} else {
			// v는 부모의 오른쪽 노드
			idx = 1;
		}

		// 둘 다 차있을 때, -> 삭제가 안되도록 !
		if (this.hasLeft((MyBinNode) super.root()) && this.hasRight((MyBinNode) super.root())) {
			// two children
			throw new TwoChildrenException("TwochildException!!");
		}
		// 왼쪽이 있을 때
		else if (this.hasLeft((MyBinNode) super.root())) {
			MyBinNode children = (MyBinNode) v.children().get(0);
			parent.children().set(idx, children);
			children.setParent(parent);

		}
		// 오른쪽이 있을 때
		else if (this.hasRight((MyBinNode) super.root())) {
			MyBinNode children = (MyBinNode) v.children().get(1);
			parent.children().set(idx, children);
			children.setParent(parent);
		}
		// 둘다 없을 때
		else {
			parent.children().set(idx, null);
		}
		return v;
	}

	public void attach(MyBinNode v, MyBinNode t1, MyBinNode t2) throws NotExternalException {
		if (this.isExternal(v)) {
			this.insertLeft(v, t1.element());
			this.insertLeft(v, t2.element());
		} else {
			throw new NotExternalException("NotExternalException !!");
		}
	}

	// inherits from Class Exception
	public class TwoChildrenException extends Exception {

		public TwoChildrenException(String string) {
			// TODO Auto-generated constructor stub
		}
	}

	// inherits from Class Exception
	public class NotExternalException extends Exception {

		public NotExternalException(String string) {
			// TODO Auto-generated constructor stub
		}
	}

	public void inOrder(MyBinNode v) {

		if (this.hasLeft(v)) {
			System.out.print("(");
			inOrder(this.left(v));
		}
		System.out.print(v.element() + "");

		if (this.hasRight(v)) {
			inOrder(this.right(v));
			System.out.print(")");
		}
	}

	public void preOrder(MyBinNode v) {

		System.out.print(v.element() + "");
		if (this.hasLeft(v)) {
			preOrder(this.left(v));
		}
		if (this.hasRight(v)) {
			preOrder(this.right(v));
		}
	}

	public void postOrder(MyBinNode v) {

		if (this.hasLeft(v)) {
			postOrder(this.left(v));
		}
		if (this.hasRight(v)) {
			postOrder(this.right(v));
		}
		System.out.print(v.element() + "");
	}

	public int postOrder2(MyBinNode v) {
		if (this.isExternal(v)) {
			return Integer.parseInt((String) (v.element()));
		} else {
			int x = postOrder2(v.left());
			int y = postOrder2(v.right());

			int return_val = 0;

			switch ((String) v.element()) {
			case "+":
				return_val = x + y;
				break;
			case "X":
				return_val = x * y;
				break;
			case "*":
				return_val = x * y;
			case "-":
				return_val = x - y;
				break;
			}
			return return_val;

		}
	}
}
```

### postOrder Traverse

```java
public int postOrder2(MyBinNode v) {
		if (this.isExternal(v)) {
			return Integer.parseInt((String) (v.element()));
		} else {
			int x = postOrder2(v.left());
			int y = postOrder2(v.right());

			int return_val = 0;

			switch ((String) v.element()) {
			case "+":
				return_val = x + y;
				break;
			case "X":
				return_val = x * y;
				break;
			case "*":
				return_val = x * y;
			case "-":
				return_val = x - y;
				break;
			}
			return return_val;

		}
	}
```

---

하영국 교수님 자바 수업
