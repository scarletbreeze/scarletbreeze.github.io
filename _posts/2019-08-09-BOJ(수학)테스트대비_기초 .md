---
layout: post
title: (BOJ)2019_역량_테스트_기초(1~6)
categories: [algorithm]
excerpt: ' '
comments: false
share: false
tags: algorithm BOJ 2019(백준)SW준비_기초
date: 2019-08-09
---

# 목차

1. [나머지](https://www.acmicpc.net/problem/3052)
2. 최대공약수와 최소공배수
3. 최소공배수
4. GCD의 합
5. 소수 찾기
6. 골드바흐의 추측

## 1. 나머지 3052

- 수 10개를 입력 받은 뒤, 이를 42로 나눈 나머지를 구한다.
- 그 다음 서로 달느 값이 몇 개 있는지 출력하는 프로그램 작성

> 1. 수 10개를 입력 받는다.
> 2. 나머지를 담을 집합 선언
> 3. for문을 돌면서 42로 나누었을 때 나머지를 집합에 넣는다.
> 4. 집합의 원소 개수 출력

```python
S = set()
for i in range(10):
    T = int(input())
    S.add(T % 42)

print(len(S))
```

### 배운 것

- set은 dict 타입과 동일한 중괄호를 사용하므로, 중괄호 만으로 생성할 수 없다.
- 따라서 set() 생성자를 사용한다.
- ※ 원소 추가는 add
- ※ 여러 값을 한번에 추가할 때는 update
- ※ 원소의 제거는 remove
- ※ copy는 얕은 복사
- [집합 관련 메소드 참고](https://wikidocs.net/16044)

## 2. 최대공약수와 최소공배수 2609

- 두 개의 자연수를 입력 받아 최대공약수와 최소공배수 출력

> 유클리드 호제법 기억해야한다.
> (a>b)a,b에 대해서 a를 b로 나눈 나머지가 r이라고 한다면, a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
> 이 성질에 따라, b를 r로 나눈 나머지 r을 구하고, r을 r2로 나눈 나머지를 구하는 과정을 반복하여 0이 되었을 때
> 나누는 수가 a와 b의 최대공약수이다.

- 0으로 나누어 떨어지지 않는 수가 나올 경우도 고려해주어야 한다.

```python
def GCF(a, b):  # greatest common facter
    while True:
        a, b = b, a % b
        if not b:  # 0으로 나누어 떨어지지 않으면
            return a
        elif not a % b:
            return b
def LCD(a, b):
    lcd = GCF(a, b)
    return a*b//lcd
a, b = map(int, input().split())
print(GCF(a, b))
print(LCD(a, b))
```

### 배운 것 복습

```python
def gcd(m,n):
    while n:
        t = m%n
    m,n = n,t
    return abs(m)
```

- 위 코드가 훨씬 깔끔하다.
- while 문의 조건에 n을 넣어줘서, 따로 if문을 걸어줄 필요를 없앴으며
- 4,2와 같은 0으로 % 연산을 하게 되는 경우도 방지할 수 있다.

---

참고자료
[BOJ문제]<https://www.acmicpc.net/problem/15649>
