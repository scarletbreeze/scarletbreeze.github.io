---

title:  프로그래밍 언어론 (필기정리 0321/0326)
tag: class 

---

## 2.2 번역기와 소프트웨어 시뮬레이션

언어 구현 -> 크게 3가지 
①컴파일 ②소프트웨어 시뮬레이션(해석) ③하이브리드 : 번역 + 소프트웨어 시뮬레이션

### 번역기
*	고급언어로 작성된 원시 프로그램을 목적 기계어(프로그램)로 번역 
*	목적기계 명령어 해독기는 기계어를 기본연산으로 수행

목적기와 번역기가 다를 때 -> **크로스 컴파일러**.
번역기 -> 명시적으로 번역 단계와 / 실행 단계가 있음  (컴퓨터는 서로 다른 컴퓨터가 될 수 있다.)

**장점**: 실행머신에 맞게 빠른 언어 실행 가능.
**단점**: 번역이 무조건 필요. 불편하며 비용이 많이 든다.

Q) 번역기는 왜 필요할까?

단말기 프로그램 같은 경우. 어디서 개발해야해 ? -> 개발 환경이 없잖아.
즉 핸드폰 단말기 -> 고급언어로 작성하고 싶으니까. 그 떄 사용되는 컴파일러 -> 단말기에 맞는 형태로 번역 목표

☆object를 동작하고자 하는 머신에 번역기가 존재하지 않을때 

### 번역기의 형태

```
고급언어 -> 전처리기 -> 고급언어 -> 컴파일러 -> 목적 모듈 -> 링커 -> 적재 모듈 -> 적재기-> 수행(입력자료가고 출력자료 옴)
```
경우에 따라 전처리기가 필요할 수도 있다.
ex) c언어 같은 경우 전처리 문장을 가짐.
ex) #define -> define 할 때, 확장. 함수 정의시 -> 전처리 단계에서 마커 정의, 전처리 문장이기에 인수 대신 대체되서 들어감
이외에도 컨디셔널(번역해서 취급 안하는 부분 포함하기도)
ex) include

(C++을 위한 번역기 나오기 전 빠르게 하기 위해 전처리 단계에서 c++을 c로 바꾼뒤에 구현한 적도 있다.)

분리해서 컴파일 하는 경우 결합하는 파일을 포함해야 한다 .
그 함수를 쓰기 위한 명세 부분은 호출 할 때 표현하고 있엉만 옳게 번역 가능하다 -> 분리 컴파일

### 번역기의 종류

*	어셈블리어
	*	원시언어 : 어셈블리어
	*	목적언어 : 기계어
	*	목적언어와 원시언어는 1대1로 대응.

*	컴파일러 
	*	원시언어 : 고급언어
	*	목적언어 : 기계어와 가깝거나 어셈블리어
	*	c, c++ 언어

*	번역기의 종류
	* 원시 언어 : 재배치가 가능한 코드
	* 목적 언어 : 실제 기계어
	
*	전처리기
	* 원시 언어 : 고급 언어
	* 목적 언어 : 동일 언어와 같은 표준 형태
	* c언어 전처리기

### Binding 필기

**일단 바인딩이 뭐야?**
**컴퓨터 프로그래밍에서 각종 값들이 확정되어 더 이상 변경할 수 없는 구속 상태가 되는 것**. 프로그램 내에서 변수, 배열, 라벨, 절차 등의 명칭, 즉 식별자가 그 대상인 메모리 주소, 데이터형 또는 실제값으으로 배정되는 것이 이에 해당되며,
**원시 프로그램의 컴파일링 또는 링크시에 확정되는 바인딩을
정적 바인딩이라 하고,**
**프로그램의 실행되는 과정에서 바인딩 되는 것을 동적바인딩 이라 한다. **

Binding -> 프로그램 실행 이전 (정적 바인딩)
(실행시간, 컴파일러 언어)

프로그램 실행 과정 -> (동적 바인딩)

인터프리터 언어 : 실행하는 과정에서 자유롭게 바뀔 가능성이 높다. 

고유의 인터프리터 -> 언어의 특성 반영(컴파일 하면 반영이 되지 않는다.) 실행의 유통성 발휘

초기 메모리가 크지 않았을 때 기억공간이 작았기에 컴파일 활용하지 않았다.
따라서 당시는 인터프리터만 가능했던 시기다
그 때 BASIC이 개발됌

그렇다면 완전히 컴파일만 있고 완전히 인터프리터만 있을까?
그렇지 않다.

완전히 인터프리테이션만 있다면 -> 실행 속도문제가 있다.
또한 인터프리터 비용이 많이 든다. 
(COMMAND -> 운영체제 대화 명령어. 번역이 안된다. 그런 커맨드 들을 프로그램화 할 수 있는 것이 언어들. 번역해봐야 비용만 더 듬)
인터프리터 장점 : 구현이 용이하다. 컴파일러는 타겟머신과 무관하게 동작한다.  쉽다. 
해석기를 이용해서 구현. 간단한 테스트시, 초기 코딩시 번역 비용이 절감된다.


컴파일 하는 경우: 운영체제에 맞는 형태로 object 생성해줌. 번역하다보면 너무 많은 object 코드 생성

번역시 긹-> 많으면 하나의 명령어가 수백개의 코드로. 따라서 코드사이즈가 올라가서 비효율적이다. 
sub루틴을 만들어서 결과를 얻어내는게 나을 수도. 코드 커짐 방지.
overhead -> macro는 실행이 바로 되는 반면 
sub 루틴 -> 프로그램 카운터가 왔다갔다함. 따라서 속도 저하.

일반적으로 명령어 코드가 다 있지 않다.
해석 방법으로 인터프리테이션을 포함시킨다.
소프트웨어 시뮬레잇녀 하는 부분을 포함.
실행중-> 라이브러리 쪽으로 갔다와야함

단점 -> 서브루틴으로 제어
장점 -> 입출력 library제작시  코드 사이즈 1번만,

### 소프트웨어 시뮬레이션 (해석)

**기법 : 고급 언어를 다른 기계에서 소프트웨어로 시뮬레이션 수행**

### 하이브리드 방법
**기법: 고급언어를 중간 형태 가상(추상)기계 코드로 번역
가상(추상)기계에 대한 소프트웨어로 시뮬레이션 수행
**

### 소프트웨어 시뮬레이션과 번역의 차이

| 항목  | 소프트웨어 시뮬레이션  | 번 역  |
|---|---|---|
| 원시 입력  | 고급 언어  |  고급 언어  |
| 수행  |  고급 언어 | 고급언어와 동일의미의 목적(기계) 언어  |
| 원시 프로그램 추적  | 쉽게 이용  | 어려움 | 
| 장점  | 사용자 적응성 제공/ 원시프로그램 정보 이용 가능 | 실행 시간의 효율성 제공/ 반복문, 부프로그램등과 같이 많 은 횟수 반복처리  | 
| 단점  | 실행 시간 비효율적 / 반복되는 문자 처리 / 프로그램 수행 시 반복적인 해독  | 원시 프로그램 정보 유실 / 목적 모듈의 크기 증가로 큰 기억장치 요구  | 
| 프로그래밍 언어  | Lisp, AOL, SNOBOL4, Prolog, ML, Smalltalk  | Fortran, Cobol, PL/I, Algol, Pascal, Ada, C  |

## 2.3 가상 컴퓨터와 바인딩 시간


가상 컴퓨터 계층 -> 하드웨어 -> 펌웨어(소프트웨어가 들어가 있지만 하드웨어) -> 운영체제 
ex) 임베디드 -> 운영체제 없이 펌웨어에서 동작 (어셈블리어의 형태)


### 바인딩
*	개념
	*	프로그래밍 언어의 기본 단위(요소)가 택할 수 있는 여러 속성 중에서 일부를 선정하여 결정(결합)하는 행위
	*	이름 또는 식별자를 사용하여 이름과 속성을 연결하는 과정
	*	ex) int c = 5 //c라는 이름에 정수 속성과 값 5를 대입하는 바인딩

### 바인딩 시간
*	바인딩이 발생되는 시간
*	종류 
	*	실행 시간 
	*	번역 시간
	*	언어 구현시
	*	언어 정의시
	* 	아래로 갈수록 빠르다.

Q) 변수는 타입이란 속성 말고 또? 어떤거 ?
*	기억 공간과의 바인딩 -> 컴파일 언어 초기 고급 언어 당시 기억공간 바인딩 : 정적
*	실행 직전에 변수와 결합 확정 후 바꾸지 않는다. 실행 과정에서 그 속성 변하지 않음
*	인터프리터 언어 : 기억공간과의 바인딩이 동적. 변수 타입 속성 -> 경우에 따라 다름. 
*	기억 공간 정적으로만 ? -> block 구조에 문제가 생긴다. 동적에 대한 부분을 포함해야. 따라서 기억공간 관리를 동적으로 해줘야 한다.
*	상수와 변수 -> 기억공간에 어떤 것 할당 -> 변수. 명령에 따라 바뀜, 실행 중 변화 

### 실행 시간 바인딩
*	 프로그램이 실행될 때 발생하는 바인딩 - 동적 바인딩 , 변수값 배정, 변수와 자료구조에 기억 장소 할당
*	 부프로그램과 블록의 시작 바인딩 - 형식 매개 변수와 실제 매개 변수간의 바인딩 지역 변수에 대한 기억 장소 할당
*	 실행시 임의의 시점 바인딩 - 배정문을 통하여 값을 변수에 저장하는 바인딩

### 번역 시간 바인딩

*	 언어를 번역하는 시간에 발생하는 바인딩을 의미 : 정적 바인딩
*	 프로그래머에 의해서 선택된 바인딩 : 변수의 형, 문장, 구조에 대한 결정
*	 번역기에 의해서 선택된 바인딩 : 저장소의 상대 위치, 배열의 명세표
*	 적재기에 의한 바인딩 : 번역기는 다수의 부프로그램 결합 시 상대 주소 결정, 적재기는 절대 주소로 변경

### 그 외 바인딩 시간의 종류
*	언어 구현시
	* 언어 구현 시 : 언어 정의 시 원소들에 특성을 한정하지 않고 언어를 컴퓨터 상에서 구현할 때 특성의 일부를 확정하는 바인딩
	* 정수의 자릿수, 실수의 유효숫자 갯수, 수의 기계 내에서의 표기법

*	언어 정의시
	* 언어를 정의할 때 확정되는 바인딩
	* 언어 구문 정의(반복문, 하용되는 자료구조, 연산 종류 등)
	* 혼합형 연산(덧셈, 곱셈)에서 두 피연산자의 형 결정에 관한 사항

### 바인딩 시간의 종류 예
*	배정문 Y := X + 10에서 발생되는 바인딩과 시간
	* 변수 x --- 현재값, 자료형, 자료형의 종류 - 이름과 타입에 대한 속성, location에 대한 속성, 들어 있는 값에 대한 속성
	* 상수 10 --- 표현 방법과 의미 -> 컴파일러 제작자에 의해 구현이 정해짐
	* 연산자 + --- 성질과 의미 -> 복합적 의미시 - 중복 제어 . 의미가 정해지면 해석을 한다. 컴파일러 +를 결정해줘야만 가능. 인터프리터 : 실행중에 덧셈의 의미 확정
	* 배정문 := --- 성질과 의미 -> 언어 정의시 결정

### 바인딩 시간의 중요성

* 컴파일 언어 : 빠른 바인딩. 효율성 증가
* 인터프리터 언어 : 늦은 바인딩, 적응성(유연성)증가

* 구현방법과 바인딩 시간
	* 번역기 -- 빠른 바인딩
	* 해석기 -- 늦은 바인딩 


### 바인딩 시간의 종류 예

--------

참고자료

[송상연님께서 알려주신 사이트](https://stackoverflow.com/questions/7991877/why-is-an-interpreter-slower-than-a-compiler-in-practice)

프로그래밍 언어 개념 - 원유헌 저

