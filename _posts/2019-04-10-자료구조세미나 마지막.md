---

title: 자료구조 세미나 마지막
tag: algorithm

---

## 자료구조 세미나 마지막

#### return 

리턴에 대해서는 크게 많이 이야기할 건 없고

이번 시험 잘 볼수 있겠니? 교수님이 내실 것 같다. 교수님 시험 문제를 본격적으로 내기 시작한게 2년.
작년 2학기 c++부터 직접 내기 시작하심. 시험문제 고차원적이다. 일개의 천민들은 이해할 수 없는 걸. 풀어서 써놓으심.

우리가 method를 만들 때, 

```
public class DS(){

	public static void main sum(String[] args) (int a,int b){
    Ds ds = new DS();
    int s = ds.sum(1,3);
	
}

	public int sum(int a, int b){
    return a+b;
    }
}
```

이거 잘못된 코드잖아.

main은 다른 공간에 있으니까. DS라는 클래스의 객체를 생성해서 코딩한다.

항상 코드 짤 때 주의할법

main과 다른 메소드는 같은 공간에 있는게 아니야
그래서 객체 생성해서 해야해.

ds.sum 해서 (1,3)을 호출했어
그러면 1은 a안으로 들어간다
3은 b안으로 들어간다

a가 1, b가 3  리턴 4.

리턴되는 애가 어디로 갈까. 저장을 해야지
int s = 4;와 똑같아진다.

s를 쓸 때, 여기에 뭐가 출력이 된다고? 4가 출력이 된다.

여러분이 쓸 때, 분명히 이 메소드가 어떤 값을 리턴해주는데, 그 리턴값을 써야하는 경우는 항상 저장을 해줘야 한다.
여러분들 코드 보면, 이걸 썼다. 이게 끝이야.
리턴하는 걸 저장하는 습관을 들여라.

리턴해줄 때는 저장을 해줘라.

(예시답안 잘못 올려서 코드 수정해야해)

코드 다 넣어야하는데, 루트를 넣을 때, 루트노드 밑에 들어가므로 add Node만 쓰면 되니 각각의 스트링만 넣어주면 된다.
그런데 US를 넣으려고 그래, 루트노드도 아니고 루트의 차일드도 아니다. 어떤 특정노드의 차일드 노드에 넣어야 한다는거다.
add Child 함수를 써야한다.
add child는 어떤 노드 밑에 넣어야하는지에 대한 정보가 필요하다. 여기서 그 어떤 노드가 누구냐. sales르 가지고 있는 노드가 필요해.
그런데 노드를 노들 떄 마다, 새로 생성한 노드를 리턴해준다.

그말은 여러분은 습관적으로 저장을 해야한다.
어떻게 ? 루트를 생성했고 루트를 저장을 했다.
sales를 만들고 sales를 저장해야한다.

대부분 다 `tree.addNode("sales");`이게 끝이었다.

어차피 다 찾아야하니까 그냥 저장을 해놔.
저장을 해놓고 밑에다가 쓰면ㄷ ㅚ되잖아.

변수에다가 다 저장해놓고, US를 넣을 떄, 부모노드가 누군지 넣어줘야 하니까. 넣어준거야.

내일 저 코드가지고 상속받아 쓸거야. 알아놔라.

리턴을 해라 -> 다 저장해라. 메모리의 효율성 따질 시간이 아니야. 효율성 보다는 일단 구현이 중요해.

리턴을 하면 무조건 저장해라.

언젠간 쓴다. 반드시 쓰게 되어 있다.

## NodeList

저번 시간에 못했던 NodeList를 생성하고 그 떄 만든 노드에는 parent object, children이란 어레이리스트가 있었어. 그 특성을 가지고 있었어. 부모가 필요하고 자식이 필요해. 트리는. 그런데 NodeList는 앞 전후 관계야 링크드 리스트야.

노드끼리 앞 뒤가 붙어 있는 관계다. 앞뒤를 공유하는 관계.
앞 뒤, 그다음 자기 자신 object가 필요하다.
그림을 그려보면 결국 선들이 내가 필요한 데이터들이다. 자기자신 오브젝트 필요하고 앞노드 뒷노드가 필요하다.
노드의 엘리먼트 프리뷰어스 넥스트 세가지 변수가 들어간다.

이거보고 노드를 작성을 하시고
이걸 위해서 노드리스트 클래스 생성.
아래와 같은 명세를 완성해라.
이걸 해봄으로써 자료구조 실습한번 더한다고 생각하면 된다.

헤더와 트레일러 처음에 노드 몇개 ? 이거 두개도 노드이긴 한데 실제 오브젝트를 담고 있지 않으므로 0개로 시작한다.
여기 하나가 안들어갔다. 뭐가 안들어갔을까. 
헤더와 트레일러가 선언은 되어 있다. 

헤더와 트레일러 선언만 되어있지 인스턴스화 시켜줘야 한다.

```
header = new Node();
trailer = new Node();

heade.setNext(trailer);
trailer.setPrev(header);
```
이렇게 초기화를 해줘야 한다.


first는 헤더와 first 사이를 반환하면 된다.

prev는 인자로 p가들어간다.

p.getPrev();이거하면된다

next도 p의 다음노드 반환
p.getNext(); 하면 끝.
메소드들은 다 한줄 두줄에서 끝난다.

set
p.setElement(e);
하면 끝나는ㄱ ㅓ지.

이제 아래 네개만 중요하다.

addAfter(Node p, object e){

}

addAfter(B,"c"); 이렇게 했다고 치자.
A와 B가 들어있는데.

이걸 예로 들자

``

```
addAFter (A, "c")

Nod newNode = new Node("c");

A.getNext().setPrev(newNode);
newNode.setNext(A.getNext());
A.setNext(newNode);
newNode.setPrev(A);
```

모든 힌트를 다 드렸음.
이것 꼭 알아두자.

## GameHistory

그 전에 저희가 만든 노드리스트
노드의 엘리먼트 값 하나 있다. 그런데 여기다가 과제할 때, intergerSize할 때, 사이즈 추가했잖아.
Node에다가 Player이름만 추가해라.

그렇게 해서 모든 끝말잇기 단어들을 노드리스트에서 이어가라.

그러면 된다.



- - -
 
참고자료 

소프트웨어 아카데미
S/W Problem Solving
