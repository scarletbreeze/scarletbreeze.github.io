---
layout: post
title: programmers_고득점키트(DFS,BFS)
categories: [algorithm]
excerpt: ' '
comments: false
share: false
tags: algorithm programmers 파이썬고득점키트
date: 2019-08-02
---

## 깊이/너비 우선 탐색(DFS,BFS)

### 1. 타겟넘버

- ![No Image](/assets/posts/20190802/1.png)

* 반복문 이용

```python
def solution(numbers, target):
    answer = [0]
    for i in numbers:
        temp = []
        for j in answer:
            temp.append(j+i)
            temp.append(j-i)
        answer = temp
    return answer.count(target)


print(solution([1, 1, 1, 1, 1], 3))
```

- ![No Image](/assets/posts/20190802/2.png)
- 재귀함수 이용

```python
def solution(numbers, target):
    if not numbers and target == 0:
        return 1
    elif not numbers:
        return 0
    return solution(numbers[1:], target + numbers[0]) + solution(numbers[1:], target-numbers[0])
```

### 2. 네트워크

- 문제를 이해하는 데에도 많은 시간이 걸렸던 문제.
- BFS를 사용한, 완전 탐색 문제다.

```python
def Network(computers, visited, SNode):
    stack = [SNode]  # idx를 스택에 넣고 시작
    while stack:  # 스택이 빌 때까지
        path = stack.pop()  # 스택에서 하나 꺼내고
        if not visited[path]:
            visited[path] = True
        for i in range(len(computers)):
            if computers[path][i] == 1 and not visited[i]:
                stack.append(i)


def solution(n, computers):
    answer = 0
    visited = [False for i in range(n)]  # 방문한 노드 개수 표시
    idx = 0
    while not all(visited):  # 전부다 방문할 때까지 반복
        if not visited[idx]:
            Network(computers, visited, idx)
            answer += 1  # 처음 방문한 것이기 때문에 네트워크 개수를 늘려준다.
        idx += 1
    return answer


print(solution(3, [[1, 1, 0], [1, 1, 0], [0, 0, 1]]))

```

---

참고자료
[프로그래머스]<https://programmers.co.kr/learn/challenges>
[파이썬 문자열 비교]<https://webisfree.com/2017-08-23/python%EC%97%90%EC%84%9C-match-string-%EC%9D%BC%EC%B9%98%ED%95%98%EB%8A%94-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B0%BE%EB%8A%94-%EB%B0%A9%EB%B2%95>
