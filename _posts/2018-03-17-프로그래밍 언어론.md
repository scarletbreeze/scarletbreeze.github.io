---

title:  프로그래밍 언어론 (chapter1-3)
tag: class 

---

### 1.3 프로그래밍 언어에서의 추상화
추상화 : 속성들의 일부분만을 가지고 주어진 작업이나 객체들을 필요한 정도로 묘사할 수 있는 방법을 지원하는 것.

추상화의 종류 : 자료추상화 , 제어 추상화

자료추상화 : 자료 특성 -> 개별적, 구조적, 단위 추상화로 분류

제어추상화 : 알고리즘 -> 기본적, 구조적 추상화로 분류

### 1.4 계산 전형
컴퓨터의 구조 ---> 명령형 언어 -> 비효율. 따라서 함수형 언어와 논리형 언어 등장.

### 1.5 언어 정의
-> 구문론과 의미론

## Q)되부름

장점: 간단하게 정의 가능
단점: 반드시 끝나는 조건 삽입

Q) 되부름보다 반복문이 왜 바람직한 방법일까?

-> ①기억공간 측면과 ②실행시간 측면

되부름을 하게 되면 호출될 때마다 새로운 기억공간을 요구하게 됨. 그렇지 않으면 되부름이 불가능함
(호출과 반환과의 관계 : Last In First Out)

기억공간의 확보 + 정보를 기억하여 환원까지 해줘야 한다.
따라서 실행비용이 추가로 발생.

## 프로그래밍 언어의 역사

| 년도 | 특징 | 언어 |
|:--------:|:--------:|:--------:|
| 1950 | 실행의 효율성 중시 | FORTRAN, COBOL, ALGOL60, APL, LISP |
| 1960 | 다양한 언어 | PL/I, ALGOL68, SIMULA67, BASIC, FORTRAN IV, FORTRAN66 |
| 1970 | 간결성, 추상화 | C, Pascal, Prolog, FORTRAN77, CLU, Eculid, Mesa |
| 1980 | 새로운 방향, 언어의 논리, 수학적 개념 | Ada, Smalltalk, C++, ML, Modular2, Scheme, Common LISP, MIRANDA, SETL, Eiffel |
| 1990 | 인터넷 대중화, 컴포넌트 개념 도입| JAVA, C#, PHP, HTML, XML |

## 1950년대
*	환경
	* 수치 계산 위주
	* 고가의 장비 사용
	* 실행의 효율성 중시

*	특징 
	*	기계의존적, 자연 언어 문법과 상이한 구문


*	언어
	*	어셈블리 언어
	*	FORTRAN, LISP, COBOL, ALGOL60, APL
	*	프로그래밍 기법 영향


#### FORTRAN
*	최초의 고급 프로그래밍 언어
*	컴파일러 사용 : 효율적인 기계어 생성
*	제어 구문 등의 사용으로 이후 언어에 영향

#### COBOL
*	레코드 자료 구조 도입
*	자료 구조와 실행 코드 분리
*	문서출력의 다양화 제공(PICTURE을 써서)
*	사무처리를 위해 채책, 문법이 복잡하다는 단점

#### ALGOL 60

*	추상화 -> Block 개념 도입 ->
① 부프로그램 ② 기억공간활용 
->한 덩어리로 묶어주는 것 - 캡슐화 한다 -> 이름의 자유도 상승

(부프로그램이란 subprogram, 즉 특정한 일을 여러번 실행할 필요가 있을 때 이를 실행하기 위해 논리적으로 별개의 프로그램으로 작성된 프로그램을 말한다. 되부름될 때마다 샐운 기억공간이 활용되어야 recursive한 프로그램이다.)

*	스택 기반 실행 환경 도입 
*	BNF 형태 최초 사용 (정형화 방법)

#### LISP 
*	인공지능 표현 언어
*	리스트 구조와 함수 구조 적용
*	쓰레기 수집 전략 개념 도입
*	되부름의 원조

#### APL
* 	최초의 시분할 시스템 사용
* 	배열과 행렬에 대한 연산 요이
* 	단점 : 제어구조 없음, 그리스 기호 사용, 가독성 낮음

## 1960년대
언어개발 대중화, 특수 목적 언어 개발,

#### PL/I
*	IBM만 지원. 다른 회사 언어 지원x -> 사양.
*	병행성, 기억장소 할당, 예외처리 도입
*	번역기 작성 난해함. 실행 효율 저하

#### ALGOL68
*	Algol 60+ 타 언어 기능 + 일관된 구조
*	완벅한 직교성 제공. 이론적으로 완벽
*	메뉴얼의 복잡성(개념은 좋지만 구현이 힘들다)

#### SNOBOL 
*	문자열 처리 언어

#### BASIC
*	비 과학자를 위한 수치계산
*	단순한 언어 구문

## 1970년대
*	하드웨어의 발전에 비해 소프트웨어 발전이 더딤
*	하드웨어와 소프트웨어 비용 역전 추세
*	언어의 간결성, 일관성을 추구하며 추상화 및 병행성 도입

### Q) 구조적 프로그래밍이란 ?
*	프로세스 지향적인 관점에서 프로그래밍 하는 방법
*	때론, 절차식 프로그래밍이라고도 함
*   블록이라는 단위를 이용하여 프로그램 작성
* 	goto 문법의 사용 금지
* 	제한된 제어구조 만을 사용(순차구조, 반복구조, 선택구조)
* 	특정 프로그램내에서 하나의 시작점을 갖는 함수는 반드시 하나의 종료점을 갖음


#### PASCAL
* 블록 구조 절차 언어
* one in one out -> 직선형 수행 가능, 판독성 좋아짐(디버깅 유지보수 등 비용절감)
* 강력한 형 검사
* ALGOL68에서 생성

#### C
*	범용 언어
*	하드웨어 접근 용이 : 시스템 프로그래밍 가능
*	UNIX 운영체제 개발 언어 사용 -> 대중화 기여(공통으로 쓸 수 있는 운영체제를 만들어보자-> 고급 언어를 통해서만 가능 -> 새롭게 고안 C 언어)

#### 1970년대 중, 후반 언어
*	자료 추상화, 병행성 증명 등의 매커니즘을 집중적으로 시도
*	소프트웨어의 위기 : 비용 증가 -> 생산성 향상을 위한 노력 -> 디버깅 시간 증가=> 프로그래밍  언어 간결화 + 추상화 => 디버깅 쉬워지고 신뢰도가 올라감. 유지보수 향상
*	CLU : 추상화 기법
*	Euclid : Pascal의 단점인 이명 개선
*	Mesa : 시스템 프로그래밍 용

#### 1980년대 
*	개인용 컴퓨터 확산
*	논리 작성용 언어 등장
*	객체 지향 언어 연구 활봘

#### ADA
*	군용 분야, 범용
*	추상 자료형, 패키지 소프트웨어 요소들의 집합
*	병렬 프로그래밍 지원
*	대규모 프로그래밍 지원

#### c++
*	추상화 캡슐화를 도입
*	객체지향 설계 + c언어
*	C언어보다 강력한 형검사
*	
#### 1980년대 등장한 함수형 언어
*	스킴, Common Lisp, ML, Miranda

#### 1980년대 등장한 기타 언어
*	Prolog(논리형 언어), SETL(, Smalltalk(객체지향 언어의 모범), C++(c언어를 확장한 객체 지향 언어). Eiffel(객체 지향 언어)

## 1990년대 이후
*	인터넷 확산
*	분산 컴퓨팅 기술 개발
*	큰 규모 라이브러리, API 사용 증대
*	웹지원 언어, 스크립 언어, 마크업 언어

#### JAVA
*	객체지향적, 분산 네트워킹을 지원
*	C++기반 많은 구조 삭제, 일부 구조 변경, 일부 구조 추가
*	C++의 강력함과 유연성 제공, c++보다 규모는 작아지고, 간결하고 신뢰성 증가
*	OS 및 H/W 플랫폼에 독립적, 이식성 높음
*	인터프리터 방식, 동적
*	간결성과 신뢰성 제공 원칙

#### C# 
*	컴포넌트 기반 언어
*	Visual Basic과 C++결합
*	개방형 언어 구조
*	컴파일 기법을 활용한 다중플랫포모 지원 방안 적용

# 1.3 무엇이 좋은 언어를 만드는가? (평가/설계 기준)

* 주요 언어 설계 목적
	*	Fortran - 실행의 효율성
	*	Cobol - 영어와 유사한 문법 구조, 프로그램 판독성 용이
	*	Algol 60 - 블록 구조 제공으로 알고리즘 작성 용이
	*	Pascal - 간단한 명령형 언어, 하향식 설계 증진
	
*	설계 기준의 역사적 변천

1950 년대

*	 초기에는 실행의 효율성 중시 ex) Fortran
*	Cobol과 Algol 60의 등장으로 효율성보다 일반적인 원칙 중시

1960년대

*	복잡성 제어 필요성 인식, 추상화 기법, 언어 규칙과 제한의 감소 필요성

1970년대

*	간결성과 추상화를 강조
*	언어 구성에 수학적 정의 도입
*	프로그램의 정확성 증명 기법을 갖춘 언어 제공 -> 프로그램 신뢰성 증진

1980년대 

*	언어에 논리 또는 수학 개념의 삽입 증진
*	논리를 프로그래밍 언어 자체에 포함
*	함수형 언어에 관심, 객체 지향 언어에 관심 증가

좋은 언어의 특징

*	간결성, 명료성, 단일성,
*	직교성
*	응용 프로그램에 자연적
*	추상화 지원
*	프로그램의 검증 및 신뢰성
*	프로그래밍 환경 및 지원
*	프로그램의 이식성(기계 독립성)
*	사용 비용(효율성)

간결 명료 일치(단일)성

*	구문과 의미
	*	구문 : 표기(작성)하는 규칙(방법)
	*	의미 : 구문 구조에 대한 뜻(의미)
		*	정적의미 / 동적의미
	*	간결성
		*	명령문 갯수의 최소화
		*	구문 구조의 단순
	*	독해성 (판독성)
		*	간결하고 암호적인 언어

직교성

*	정의 		
	* 모든 가능한 기본 구조의 조합을 통하여 프로그램을 구축 가능
	* 예외적 규칙의 최소화를 통한 개념적 단순화 필요

*	장점
	* 언어 습득력 증가
	* 쉬운 프로그램 개발

* 	단점

	* 논리적 오류 가능성
	* 비효율 코드 발생
 	
응용 프로그램에 자연적

*	언어는 표준화된 특성과 개념으로 개발
*	알고리즘 논리 구조 = 프로그램 구조

추상화

*	주어진 작업이나 객체를 속성들의 일부분을 가지고 필요한 만큼 묘사할 수 있는 방법을 지원하는 것

프로그래밍 언어의 추상화

*	데이터 추상화 - 데이터 구조, 데이터 타입(형), 연산 구성
*	제어 추상화 - 수행 순서 제어
*	기본적, 구조적, 단위적 추상화

프로그래머의 역할

*	개발 대상에 대한 개념적인 추상화
*	프로그래밍 언어를 이용한 구체화된 추상화

프로그래밍 검증 및 신뢰성

프로그래밍 환경 및 지원

*	프로그램 개발 필요 도구 지원 : 통합개발환경(IDE)

프로그램의 이식성

*	기계 독립적인 언어 정의를 통하여 보장
*	기억 장소 할당과 기계 구조와 별갤 정의된 자료형 사용

사용 비용 ( 효율성 )

*	실행비용(목적코드 효율성)
	* 최적화된 컴파일러, 효율적인 레지스터 할당

*	프로그램 번역 비용(번역/구현의 효율성)
	*	언어 교육 과정에서의 번역 시간
	
*	프로그램 작성, 테스팅 비용(프로그래밍 효율성)
	*	최소한의 시간과 노력으로 설계,코딩,테스트,변경

*	유지보수비용
	* 비용이 가장 많이 듬, 하드웨어나 운영체제 변경에 의한 프로그램 수정, 프로그램 확장 개선

    
    

--------

참고자료

프로그래밍 언어 개념 - 원유헌 저

